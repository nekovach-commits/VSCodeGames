<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bridge Test - TRS-80 System</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div id="retro-container" tabindex="0">
    <canvas id="retro-canvas"></canvas>
    <div id="keyboard-area">
      <div>
        <p>BRIDGE TEST - TRS-80 MODEL 100</p>
        <p>Type anything • ENTER: new line • BACKSPACE: delete</p>
        <p>Resolution: <span id="resolution-info">Loading...</span></p>
      </div>
    </div>
  </div>

  <script>
    console.log('=== BRIDGE TEST STARTING ===');
    
    let canvas, ctx;
    let textBuffer = [];
    let cursorRow = 0, cursorCol = 0;
    let resolutionInfo;
    
    // Initialize text buffer (10 lines x 40 chars)
    for (let i = 0; i < 10; i++) {
      textBuffer[i] = new Array(40).fill(' ');
    }
    
    // Add initial text
    const initText = "TRS-80 MODEL 100";
    for (let i = 0; i < initText.length; i++) {
      textBuffer[0][i] = initText[i];
    }
    
    const readyText = "READY";
    for (let i = 0; i < readyText.length; i++) {
      textBuffer[2][i] = readyText[i];
    }
    
    // Set cursor position
    cursorRow = 4;
    cursorCol = 0;
    
    // Font data (simplified)
    const FONTS = {
      'A': [0b01110,0b10001,0b10001,0b11111,0b10001,0b10001,0b10001],
      'B': [0b11110,0b10001,0b10001,0b11110,0b10001,0b10001,0b11110],
      'C': [0b01110,0b10001,0b10000,0b10000,0b10000,0b10001,0b01110],
      'D': [0b11110,0b10001,0b10001,0b10001,0b10001,0b10001,0b11110],
      'E': [0b11111,0b10000,0b10000,0b11110,0b10000,0b10000,0b11111],
      'H': [0b10001,0b10001,0b10001,0b11111,0b10001,0b10001,0b10001],
      'I': [0b01110,0b00100,0b00100,0b00100,0b00100,0b00100,0b01110],
      'L': [0b10000,0b10000,0b10000,0b10000,0b10000,0b10000,0b11111],
      'M': [0b10001,0b11011,0b10101,0b10001,0b10001,0b10001,0b10001],
      'O': [0b01110,0b10001,0b10001,0b10001,0b10001,0b10001,0b01110],
      'R': [0b11110,0b10001,0b10001,0b11110,0b10100,0b10010,0b10001],
      'S': [0b01110,0b10001,0b10000,0b01110,0b00001,0b10001,0b01110],
      'T': [0b11111,0b00100,0b00100,0b00100,0b00100,0b00100,0b00100],
      'Y': [0b10001,0b01010,0b00100,0b00100,0b00100,0b00100,0b00100],
      '0': [0b01110,0b10001,0b10011,0b10101,0b11001,0b10001,0b01110],
      '1': [0b00100,0b01100,0b00100,0b00100,0b00100,0b00100,0b01110],
      '8': [0b01110,0b10001,0b10001,0b01110,0b10001,0b10001,0b01110],
      '-': [0,0,0,0b11111,0,0,0],
      ' ': [0,0,0,0,0,0,0]
    };
    
    function drawChar(char, x, y) {
      const fontData = FONTS[char];
      if (!fontData) return;
      
      ctx.fillStyle = '#1a3d1a';
      const CELL = 4; // Each pixel is 4x4 screen pixels
      
      for (let row = 0; row < 7; row++) {
        for (let col = 0; col < 5; col++) {
          if (fontData[row] & (1 << (4 - col))) {
            // Draw pixel blocks with proper spacing
            ctx.fillRect(x + col * CELL, y + row * CELL, CELL, CELL);
          }
        }
      }
    }
    
    function render() {
      console.log('Rendering screen...');
      
      const CELL = 4; // Base pixel size
      const BORDER_SIZE = 20;
      const CHAR_WIDTH = (5 + 1) * CELL; // 5 pixels wide + 1 gap = 24px
      const CHAR_HEIGHT = (7 + 1) * CELL; // 7 pixels tall + 1 gap = 32px
      
      // Clear with TRS-80 colors
      ctx.fillStyle = '#c8d4b8';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw border
      ctx.fillStyle = '#1a3d1a';
      ctx.fillRect(0, 0, canvas.width, BORDER_SIZE); // Top
      ctx.fillRect(0, canvas.height - BORDER_SIZE, canvas.width, BORDER_SIZE); // Bottom
      ctx.fillRect(0, 0, BORDER_SIZE, canvas.height); // Left
      ctx.fillRect(canvas.width - BORDER_SIZE, 0, BORDER_SIZE, canvas.height); // Right
      
      // Draw background grid (authentic LCD look)
      ctx.fillStyle = '#b0c0a0';
      for (let row = 0; row < 10; row++) {
        for (let col = 0; col < 40; col++) {
          const x = BORDER_SIZE + col * CHAR_WIDTH;
          const y = BORDER_SIZE + row * CHAR_HEIGHT;
          
          // Draw character cell background grid
          for (let r = 0; r < 7; r++) {
            for (let c = 0; c < 5; c++) {
              ctx.fillRect(x + c * CELL, y + r * CELL, CELL, CELL);
            }
          }
        }
      }
      
      // Draw text from buffer
      for (let row = 0; row < 10; row++) {
        for (let col = 0; col < 40; col++) {
          const char = textBuffer[row][col];
          if (char && char !== ' ') {
            const x = BORDER_SIZE + col * CHAR_WIDTH;
            const y = BORDER_SIZE + row * CHAR_HEIGHT;
            drawChar(char, x, y);
          }
        }
      }
      
      // Draw cursor (inverse block)
      const cursorX = BORDER_SIZE + cursorCol * CHAR_WIDTH;
      const cursorY = BORDER_SIZE + cursorRow * CHAR_HEIGHT;
      ctx.fillStyle = '#1a3d1a';
      
      // Draw full character-size cursor block
      for (let r = 0; r < 7; r++) {
        for (let c = 0; c < 5; c++) {
          ctx.fillRect(cursorX + c * CELL, cursorY + r * CELL, CELL, CELL);
        }
      }
      
      // If there's a character at cursor position, draw it inverted
      const cursorChar = textBuffer[cursorRow][cursorCol];
      if (cursorChar && cursorChar !== ' ') {
        ctx.fillStyle = '#c8d4b8'; // Light green for inverted text
        const fontData = FONTS[cursorChar];
        if (fontData) {
          for (let row = 0; row < 7; row++) {
            for (let col = 0; col < 5; col++) {
              if (fontData[row] & (1 << (4 - col))) {
                ctx.fillRect(cursorX + col * CELL, cursorY + row * CELL, CELL, CELL);
              }
            }
          }
        }
      }
    }
    
    function addChar(char) {
      console.log('Adding character:', char, 'at', cursorRow, cursorCol);
      
      if (char === '\n') {
        cursorCol = 0;
        cursorRow++;
        if (cursorRow >= 10) cursorRow = 9;
      } else {
        const upperChar = char.toUpperCase();
        if (FONTS[upperChar]) {
          textBuffer[cursorRow][cursorCol] = upperChar;
          cursorCol++;
          if (cursorCol >= 40) {
            cursorCol = 0;
            cursorRow++;
            if (cursorRow >= 10) cursorRow = 9;
          }
        }
      }
      
      render();
    }
    
    function handleKey(e) {
      console.log('Key:', e.key);
      
      if (e.key.length === 1) {
        addChar(e.key);
      } else if (e.key === 'Enter') {
        addChar('\n');
      } else if (e.key === 'Backspace') {
        if (cursorCol > 0) {
          cursorCol--;
          textBuffer[cursorRow][cursorCol] = ' ';
        } else if (cursorRow > 0) {
          cursorRow--;
          cursorCol = 39;
          textBuffer[cursorRow][cursorCol] = ' ';
        }
        render();
      }
      
      e.preventDefault();
    }
    
    window.addEventListener('DOMContentLoaded', () => {
      console.log('Bridge test initializing...');
      
      canvas = document.getElementById('retro-canvas');
      ctx = canvas.getContext('2d');
      resolutionInfo = document.getElementById('resolution-info');
      
      // Calculate proper canvas size
      const CELL = 4;
      const BORDER_SIZE = 20;
      const CHAR_WIDTH = (5 + 1) * CELL; // 24px per character
      const CHAR_HEIGHT = (7 + 1) * CELL; // 32px per line
      
      canvas.width = (40 * CHAR_WIDTH) + (BORDER_SIZE * 2); // 40 chars wide
      canvas.height = (10 * CHAR_HEIGHT) + (BORDER_SIZE * 2); // 10 lines tall
      
      // Update resolution info
      resolutionInfo.textContent = canvas.width + 'x' + canvas.height;
      
      // Set up keyboard
      const container = document.getElementById('retro-container');
      container.addEventListener('keydown', handleKey);
      container.focus();
      
      // Initial render
      render();
      
      console.log('=== BRIDGE TEST READY ===');
      console.log('Click and type to test!');
    });
  </script>
</body>
</html>