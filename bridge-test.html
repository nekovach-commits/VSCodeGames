<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bridge Test - TRS-80 System</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div id="retro-container" tabindex="0">
    <canvas id="retro-canvas"></canvas>
    <div id="keyboard-area">
      <div>
        <p>BRIDGE TEST - TRS-80 MODEL 100</p>
        <p>Type anything • ENTER: new line • BACKSPACE: delete</p>
        <p>Resolution: <span id="resolution-info">Loading...</span></p>
      </div>
    </div>
  </div>

  <script>
    console.log('=== BRIDGE TEST STARTING ===');
    
    let canvas, ctx;
    let textBuffer = [];
    let cursorRow = 0, cursorCol = 0;
    let resolutionInfo;
    
    // Initialize text buffer (10 lines x 40 chars)
    for (let i = 0; i < 10; i++) {
      textBuffer[i] = new Array(40).fill(' ');
    }
    
    // Add initial text
    const initText = "TRS-80 MODEL 100";
    for (let i = 0; i < initText.length; i++) {
      textBuffer[0][i] = initText[i];
    }
    
    const readyText = "READY";
    for (let i = 0; i < readyText.length; i++) {
      textBuffer[2][i] = readyText[i];
    }
    
    // Set cursor position
    cursorRow = 4;
    cursorCol = 0;
    
    // Complete TRS-80 Font Data
    const FONTS = {
      'A': [0b01110,0b10001,0b10001,0b11111,0b10001,0b10001,0b10001],
      'B': [0b11110,0b10001,0b10001,0b11110,0b10001,0b10001,0b11110],
      'C': [0b01110,0b10001,0b10000,0b10000,0b10000,0b10001,0b01110],
      'D': [0b11110,0b10001,0b10001,0b10001,0b10001,0b10001,0b11110],
      'E': [0b11111,0b10000,0b10000,0b11110,0b10000,0b10000,0b11111],
      'F': [0b11111,0b10000,0b10000,0b11110,0b10000,0b10000,0b10000],
      'G': [0b01110,0b10001,0b10000,0b10111,0b10001,0b10001,0b01110],
      'H': [0b10001,0b10001,0b10001,0b11111,0b10001,0b10001,0b10001],
      'I': [0b01110,0b00100,0b00100,0b00100,0b00100,0b00100,0b01110],
      'J': [0b00111,0b00001,0b00001,0b00001,0b10001,0b10001,0b01110],
      'K': [0b10001,0b10010,0b10100,0b11000,0b10100,0b10010,0b10001],
      'L': [0b10000,0b10000,0b10000,0b10000,0b10000,0b10000,0b11111],
      'M': [0b10001,0b11011,0b10101,0b10001,0b10001,0b10001,0b10001],
      'N': [0b10001,0b11001,0b10101,0b10011,0b10001,0b10001,0b10001],
      'O': [0b01110,0b10001,0b10001,0b10001,0b10001,0b10001,0b01110],
      'P': [0b11110,0b10001,0b10001,0b11110,0b10000,0b10000,0b10000],
      'Q': [0b01110,0b10001,0b10001,0b10101,0b10011,0b01110,0b00001],
      'R': [0b11110,0b10001,0b10001,0b11110,0b10100,0b10010,0b10001],
      'S': [0b01110,0b10001,0b10000,0b01110,0b00001,0b10001,0b01110],
      'T': [0b11111,0b00100,0b00100,0b00100,0b00100,0b00100,0b00100],
      'U': [0b10001,0b10001,0b10001,0b10001,0b10001,0b10001,0b01110],
      'V': [0b10001,0b10001,0b10001,0b10001,0b10001,0b01010,0b00100],
      'W': [0b10001,0b10001,0b10001,0b10001,0b10101,0b11011,0b10001],
      'X': [0b10001,0b01010,0b00100,0b00100,0b00100,0b01010,0b10001],
      'Y': [0b10001,0b01010,0b00100,0b00100,0b00100,0b00100,0b00100],
      'Z': [0b11111,0b00001,0b00010,0b00100,0b01000,0b10000,0b11111],
      '0': [0b01110,0b10001,0b10011,0b10101,0b11001,0b10001,0b01110],
      '1': [0b00100,0b01100,0b00100,0b00100,0b00100,0b00100,0b01110],
      '2': [0b01110,0b10001,0b00001,0b00010,0b00100,0b01000,0b11111],
      '3': [0b01110,0b10001,0b00001,0b00110,0b00001,0b10001,0b01110],
      '4': [0b00010,0b00110,0b01010,0b10010,0b11111,0b00010,0b00010],
      '5': [0b11111,0b10000,0b11110,0b00001,0b00001,0b10001,0b01110],
      '6': [0b00110,0b01000,0b10000,0b11110,0b10001,0b10001,0b01110],
      '7': [0b11111,0b00001,0b00010,0b00100,0b01000,0b10000,0b10000],
      '8': [0b01110,0b10001,0b10001,0b01110,0b10001,0b10001,0b01110],
      '9': [0b01110,0b10001,0b10001,0b01111,0b00001,0b00010,0b01100],
      ' ': [0,0,0,0,0,0,0],
      '.': [0,0,0,0,0,0b00100,0b00100],
      ',': [0,0,0,0,0,0b00100,0b01000],
      '!': [0b00100,0b00100,0b00100,0b00100,0b00100,0,0b00100],
      '?': [0b01110,0b10001,0b00010,0b00100,0b00100,0,0b00100],
      ':': [0,0,0b00100,0,0,0b00100,0],
      ';': [0,0,0b00100,0,0,0b00100,0b01000],
      '-': [0,0,0,0b11111,0,0,0],
      '+': [0,0b00100,0b00100,0b11111,0b00100,0b00100,0],
      '=': [0,0,0b11111,0,0b11111,0,0],
      '/': [0b00001,0b00010,0b00100,0b01000,0b10000,0b00000,0],
      '\\': [0b10000,0b01000,0b00100,0b00010,0b00001,0b00000,0],
      '(': [0b00010,0b00100,0b01000,0b01000,0b01000,0b00100,0b00010],
      ')': [0b01000,0b00100,0b00010,0b00010,0b00010,0b00100,0b01000],
      '[': [0b01110,0b01000,0b01000,0b01000,0b01000,0b01000,0b01110],
      ']': [0b01110,0b00010,0b00010,0b00010,0b00010,0b00010,0b01110],
      '"': [0b01010,0b01010,0b01010,0,0,0,0],
      "'": [0b00100,0b00100,0b00100,0,0,0,0]
    };
    
    function drawChar(char, x, y, pixelSize = 4, dotSize = 3) {
      const fontData = FONTS[char];
      if (!fontData) return;
      
      ctx.fillStyle = '#1a3d1a';
      
      // Draw 5x7 font within the 6x8 character cell with individual pixel gaps
      for (let row = 0; row < 7; row++) {
        for (let col = 0; col < 5; col++) {
          if (fontData[row] & (1 << (4 - col))) {
            // Calculate position with gaps between pixels
            const pixelX = x + col * pixelSize;
            const pixelY = y + row * pixelSize;
            ctx.fillRect(pixelX, pixelY, dotSize, dotSize);
          }
        }
      }
      // The 6th column and 8th row are left blank automatically (character spacing)
    }
    
    function render() {
      console.log('Rendering screen...');
      
      // TRS-80 specifications: 40x10 characters, each 6x8 pixels
      const PIXEL_SIZE = 4; // Each TRS-80 pixel is 4x4 screen pixels
      const PIXEL_DOT_SIZE = 3; // Each visible pixel dot is 3x3 with 1px gap
      const CHAR_WIDTH = 6 * PIXEL_SIZE;  // 6 pixels per character = 24px
      const CHAR_HEIGHT = 8 * PIXEL_SIZE; // 8 pixels per line = 32px
      const BORDER_SIZE = 20;
      
      // Clear with TRS-80 colors
      ctx.fillStyle = '#c8d4b8';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw border
      ctx.fillStyle = '#1a3d1a';
      ctx.fillRect(0, 0, canvas.width, BORDER_SIZE); // Top
      ctx.fillRect(0, canvas.height - BORDER_SIZE, canvas.width, BORDER_SIZE); // Bottom
      ctx.fillRect(0, 0, BORDER_SIZE, canvas.height); // Left
      ctx.fillRect(canvas.width - BORDER_SIZE, 0, BORDER_SIZE, canvas.height); // Right
      
      // Draw background grid (authentic LCD look)
      ctx.fillStyle = '#b0c0a0';
      
      for (let row = 0; row < 10; row++) {
        for (let col = 0; col < 40; col++) {
          const x = BORDER_SIZE + col * CHAR_WIDTH;
          const y = BORDER_SIZE + row * CHAR_HEIGHT;
          
          // Draw 5x7 character background grid with pixel gaps
          for (let r = 0; r < 7; r++) {
            for (let c = 0; c < 5; c++) {
              const pixelX = x + c * PIXEL_SIZE;
              const pixelY = y + r * PIXEL_SIZE;
              ctx.fillRect(pixelX, pixelY, PIXEL_DOT_SIZE, PIXEL_DOT_SIZE);
            }
          }
        }
      }
      
      // Draw text from buffer
      for (let row = 0; row < 10; row++) {
        for (let col = 0; col < 40; col++) {
          const char = textBuffer[row][col];
          if (char && char !== ' ') {
            const x = BORDER_SIZE + col * CHAR_WIDTH;
            const y = BORDER_SIZE + row * CHAR_HEIGHT;
            drawChar(char, x, y, PIXEL_SIZE, PIXEL_DOT_SIZE);
          }
        }
      }
      
      // Draw cursor (inverse block covering 5x7 font area)
      const cursorX = BORDER_SIZE + cursorCol * CHAR_WIDTH;
      const cursorY = BORDER_SIZE + cursorRow * CHAR_HEIGHT;
      
      ctx.fillStyle = '#1a3d1a';
      
      // Draw 5x7 cursor block with pixel gaps
      for (let r = 0; r < 7; r++) {
        for (let c = 0; c < 5; c++) {
          const pixelX = cursorX + c * PIXEL_SIZE;
          const pixelY = cursorY + r * PIXEL_SIZE;
          ctx.fillRect(pixelX, pixelY, PIXEL_DOT_SIZE, PIXEL_DOT_SIZE);
        }
      }
      
      // If there's a character at cursor position, draw it inverted
      const cursorChar = textBuffer[cursorRow][cursorCol];
      if (cursorChar && cursorChar !== ' ') {
        ctx.fillStyle = '#c8d4b8'; // Light green for inverted text
        const fontData = FONTS[cursorChar];
        if (fontData) {
          for (let row = 0; row < 7; row++) {
            for (let col = 0; col < 5; col++) {
              if (fontData[row] & (1 << (4 - col))) {
                const pixelX = cursorX + col * PIXEL_SIZE;
                const pixelY = cursorY + row * PIXEL_SIZE;
                ctx.fillRect(pixelX, pixelY, PIXEL_DOT_SIZE, PIXEL_DOT_SIZE);
              }
            }
          }
        }
      }
    }
    
    function addChar(char) {
      console.log('Adding character:', char, 'at', cursorRow, cursorCol);
      
      if (char === '\n') {
        cursorCol = 0;
        cursorRow++;
        if (cursorRow >= 10) cursorRow = 9;
      } else {
        const upperChar = char.toUpperCase();
        if (FONTS[upperChar]) {
          textBuffer[cursorRow][cursorCol] = upperChar;
          cursorCol++;
          if (cursorCol >= 40) {
            cursorCol = 0;
            cursorRow++;
            if (cursorRow >= 10) cursorRow = 9;
          }
        }
      }
      
      render();
    }
    
    function handleKey(e) {
      console.log('Key:', e.key);
      
      if (e.key.length === 1) {
        addChar(e.key);
      } else if (e.key === 'Enter') {
        addChar('\n');
      } else if (e.key === 'Backspace') {
        if (cursorCol > 0) {
          cursorCol--;
          textBuffer[cursorRow][cursorCol] = ' ';
        } else if (cursorRow > 0) {
          cursorRow--;
          cursorCol = 39;
          textBuffer[cursorRow][cursorCol] = ' ';
        }
        render();
      }
      
      e.preventDefault();
    }
    
    window.addEventListener('DOMContentLoaded', () => {
      console.log('Bridge test initializing...');
      
      canvas = document.getElementById('retro-canvas');
      ctx = canvas.getContext('2d');
      resolutionInfo = document.getElementById('resolution-info');
      
      // Calculate exact TRS-80 canvas size: 240x80 text area + borders
      const PIXEL_SIZE = 4;
      const BORDER_SIZE = 20;
      const CHAR_WIDTH = 6 * PIXEL_SIZE;  // 6 pixels per character = 24px
      const CHAR_HEIGHT = 8 * PIXEL_SIZE; // 8 pixels per line = 32px
      
      canvas.width = (40 * CHAR_WIDTH) + (BORDER_SIZE * 2); // 40 chars * 24px + borders = 1000px
      canvas.height = (10 * CHAR_HEIGHT) + (BORDER_SIZE * 2); // 10 lines * 32px + borders = 360px
      
      // Update resolution info
      resolutionInfo.textContent = canvas.width + 'x' + canvas.height;
      
      // Set up keyboard
      const container = document.getElementById('retro-container');
      container.addEventListener('keydown', handleKey);
      container.focus();
      
      // Initial render
      render();
      
      console.log('=== BRIDGE TEST READY ===');
      console.log('Click and type to test!');
    });
  </script>
</body>
</html>