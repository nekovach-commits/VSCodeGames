<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="cache-bust" content="v2025-09-24-2">
  <title>TRS-80 Model 100 Emulator - Updated 2025-09-24</title>
  <link rel="stylesheet" href="style.css">
</head>
<body style="background: #ffffff !important; color: #000000 !important;">
  <div id="retro-container" tabindex="0" style="background: #ffffff !important;">
    <canvas id="retro-canvas" style="background: #ffffff !important; border: 1px solid #000000 !important; cursor: text;"></canvas>
    
    <input type="text" id="kindle-input" placeholder="Tap here to open Kindle keyboard and type..." 
           style="width: 100%; max-width: 500px; padding: 10px; margin: 10px 0; font-family: 'Courier New', monospace; font-size: 16px; border: 2px solid #000; border-radius: 3px;">
    
    <div style="font-size: 12px; color: #666; margin-top: 10px; text-align: center;">
      üí° <strong>Kindle Users:</strong> Type in the input box above - text will appear on TRS-80 screen<br>
      üé® <strong>Colors:</strong> Use COLOR 0-7 (Black,Red,Green,Yellow,Blue,Magenta,Cyan,White)<br>
      üìù <strong>BASIC:</strong> Try: PRINT "HELLO", COLOR 1, COLOR 2, PRINT "GREEN TEXT"<br>
      <span id="status-msg" style="color: #006600;">System Status: Loading...</span>
    </div>
    
    <script>
      // ========================================
      // DEVICE DETECTION & PIXEL SCALING
      // ========================================
      
      // Unified device detection and pixel size calculation
      function getDeviceInfo() {
        const w = window.screen.width;
        const h = window.screen.height;
        
        // Specific device resolutions - conservative for small screens
        if (w === 636 && h === 848) return { type: 'Kindle ColorSoft', pixelSize: 1 };
        if (w === 930 && h === 1240) return { type: 'Kindle Scribe', pixelSize: 2 };
        
        // General size categories - proper scaling for web
        if (w <= 768) return { type: 'Mobile', pixelSize: 1 };
        if (w <= 1024) return { type: 'Tablet', pixelSize: 2 };
        return { type: 'Desktop', pixelSize: 4 };  // Back to 4x for proper retro look
      }
      
      function getPixelSize() {
        return getDeviceInfo().pixelSize;
      }
      
      // Immediate canvas sizing - runs before modules load
      const canvas = document.getElementById('retro-canvas');
      const pixelSize = getPixelSize();
      
      // Optimized canvas size for perfect 6x8 character fit
      const charArea = { width: 40 * 6 * pixelSize, height: 20 * 8 * pixelSize };
      const border = 10; // 10px border on each side
      const width = charArea.width + (border * 2);
      const height = charArea.height + (border * 2);
      
      canvas.width = width;
      canvas.height = height;
      
      // Debug: Show what we're working with
      console.log('DEBUG: pixelSize =', pixelSize);
      console.log('DEBUG: charArea =', charArea);
      console.log('DEBUG: canvas size =', width, 'x', height);
      console.log('DEBUG: Expected chars = 40x20');
      console.log('DEBUG: Actual char size = 6x8 pixels each');
      console.log('‚úì GRID: 40√ó20 chars, 6√ó8 pixels each, scale=' + pixelSize);
      
      // Kindle Input Handler
      const kindleInput = document.getElementById('kindle-input');
      // Unified input handling - works same way for all systems
      let currentLine = '';
      let inputBuffer = '';
      let showingPrompt = false;

      // ========================================
      // APPLE IIE STYLE PROMPT SYSTEM
      // ========================================
      
      function showPrompt() {
        if (!showingPrompt) {
          UnifiedDisplay.addChar(']');
          showingPrompt = true;
          UnifiedDisplay.render();
        }
      }
      
      function hidePrompt() {
        if (showingPrompt) {
          // Remove the ] character by sending backspace
          UnifiedDisplay.addChar('Backspace');
          showingPrompt = false;
          UnifiedDisplay.render();
        }
      }

      // ========================================
      // UNIFIED DISPLAY ABSTRACTION LAYER
      // ========================================
      
      // Helper function to get ES6 display if available
      function getES6Display() {
        return window.trs80 && window.trs80.display ? window.trs80.display : null;
      }
      
      // Universal display interface - auto-detects which backend to use
      const UnifiedDisplay = {
        addChar: function(char) {
          if (window.simpleTRS80) {
            window.simpleTRS80.addChar(char);
          } else {
            const es6Display = getES6Display();
            if (es6Display && es6Display.addChar) {
              es6Display.addChar(char);
            }
          }
        },
        clearScreen: function() {
          if (window.simpleTRS80) {
            window.simpleTRS80.clearScreen();
          } else {
            const es6Display = getES6Display();
            if (es6Display && es6Display.clearScreen) {
              es6Display.clearScreen();
            }
          }
        },
        setTextColor: function(colorIndex) {
          if (window.simpleTRS80) {
            window.simpleTRS80.setTextColor(colorIndex);
          } else {
            const es6Display = getES6Display();
            if (es6Display && es6Display.setTextColor) {
              es6Display.setTextColor(colorIndex);
            }
          }
        },
        addText: function(text) {
          for (let i = 0; i < text.length; i++) {
            this.addChar(text[i]);
          }
        },
        render: function() {
          const es6Display = getES6Display();
          if (es6Display && es6Display.render) {
            es6Display.render();
          }
          // SimpleTRS80 renders automatically
        }
      };

      // ========================================
      // UNIFIED PROGRAM STORAGE ABSTRACTION
      // ========================================
      
      // Universal program storage - auto-detects which storage to use
      const UnifiedProgram = {
        storage: null,
        getStorage: function() {
          if (!this.storage) {
            if (window.trs80 && window.trs80.program) {
              this.storage = window.trs80.program;
            } else {
              this.storage = new Map();
            }
          }
          return this.storage;
        },
        set: function(lineNum, command) {
          this.getStorage().set(lineNum, command);
        },
        get: function(lineNum) {
          return this.getStorage().get(lineNum);
        },
        delete: function(lineNum) {
          this.getStorage().delete(lineNum);
        },
        clear: function() {
          this.getStorage().clear();
        },
        keys: function() {
          return this.getStorage().keys();
        },
        get size() {
          return this.getStorage().size;
        }
      };

      // ========================================
      // UNIFIED INPUT PROCESSING
      // ========================================
      
      // Unified input processing
      function processCharacter(char) {
        if (char === 'Backspace') {
          // Only allow backspace if there are characters to delete (protect the ] prompt)
          if (currentLine.length > 0) {
            currentLine = currentLine.slice(0, -1);
            UnifiedDisplay.addChar(char);
          }
          return;
        }

        if (char === 'Enter') {
          // Don't hide prompt - just move to new line and let it naturally disappear
          
          // Add newline ONLY for SimpleTRS80 (Kindle) - ES6 system handles this internally
          if (window.simpleTRS80 && !window.trs80) {
            UnifiedDisplay.addChar('\n');
          }
          
          if (currentLine.trim()) {
            // Process through SharedBasicProcessor
            if (window.SharedBasicProcessor) {
              window.SharedBasicProcessor.processLine(currentLine.trim(), UnifiedProgram, UnifiedDisplay);
            }
          } else {
            // Empty line - just add newline and show prompt again
            if (window.simpleTRS80 && !window.trs80) {
              // Already added newline above for Kindle
            } else {
              UnifiedDisplay.addChar('\n');
            }
          }
          
          currentLine = ''; // Clear line
          showingPrompt = false; // Reset prompt state since we moved to new line
          showPrompt(); // Show prompt for next input
          UnifiedDisplay.render();
          return;
        }

        // Regular character - don't hide prompt when typing, just add characters after ]
        if (char.length === 1) {
          currentLine += char;
          UnifiedDisplay.addChar(char);
        }
        UnifiedDisplay.render();
      }
      
      // ========================================
      // INPUT EVENT HANDLERS
      // ========================================
      
      kindleInput.addEventListener('input', function(e) {
        const newValue = e.target.value;
        
        // Find what was added (handle typing and pasting)
        if (newValue.length > inputBuffer.length) {
          const addedText = newValue.slice(inputBuffer.length);
          // Process each character through unified system
          for (let char of addedText) {
            processCharacter(char);
          }
        }
        
        // Find what was removed (backspace)
        if (newValue.length < inputBuffer.length) {
          const removedCount = inputBuffer.length - newValue.length;
          for (let i = 0; i < removedCount; i++) {
            processCharacter('Backspace');
          }
        }
        
        // Clear the input field to prevent duplicate display
        setTimeout(() => {
          e.target.value = '';
          inputBuffer = '';
        }, 50);
        
        inputBuffer = newValue;
      });

      // Handle Enter key specifically for command execution
      kindleInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
          const currentInput = e.target.value.trim();
          if (currentInput) {
            // Set the current line and process Enter
            currentLine = currentInput;
            processCharacter('Enter');
          } else {
            processCharacter('Enter');
          }
          
          // Clear input field
          e.target.value = '';
          inputBuffer = '';
          e.preventDefault();
        } else if (e.key === 'Backspace') {
          // Handle backspace directly since input event might not fire reliably on Kindle
          if (currentLine.length > 0) {
            currentLine = currentLine.slice(0, -1);
            UnifiedDisplay.addChar('Backspace');
          }
        }
      });
    </script>
    
    <div id="keyboard-area" style="background: #ffffff !important; color: #000000 !important;">
      <!-- Desktop Info -->
      <div id="desktop-info" style="margin-top: 15px; color: #000000 !important;">
        <p><strong>TRS-80 MODEL 100 - PORTABLE COMPUTER</strong></p>
        <p>Type anything ‚Ä¢ ENTER: new line ‚Ä¢ ESC: clear ‚Ä¢ BACKSPACE: delete ‚Ä¢ Arrow keys: navigate</p>
        <p>Resolution: <span id="resolution-info">Loading...</span></p>
        <div id="debug-info" style="margin-top: 10px; font-size: 10px; color: #666; font-family: monospace;">
          <div>Screen Resolution: <span id="screen-res">Loading...</span></div>
          <div>Canvas Size: <span id="canvas-size">Loading...</span></div>
          <div>Expected Size: <span id="expected-size">Loading...</span></div>
          <div>Device Type: <span id="device-type">Loading...</span></div>
          <div>Scale Factor: <span id="scale-factor">Loading...</span></div>
          <div>Pixel Scale: <span id="pixel-scale">Loading...</span></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ========================================
    // RESOLUTION & DEVICE INFO FUNCTIONS
    // ========================================
    
    function updateResolutionInfo() {
      const resolutionInfo = document.getElementById('resolution-info');
      
      if (resolutionInfo) {
        const info = [
          `${window.innerWidth}√ó${window.innerHeight}`,
          `Screen: ${screen.width}√ó${screen.height}`,
          `DPR: ${window.devicePixelRatio || 1}`,
          `Touch: ${'ontouchstart' in window ? 'Yes' : 'No'}`
        ].join(' ‚Ä¢ ');
        resolutionInfo.textContent = info;
      }
      
      // Update individual debug fields
      const canvas = document.getElementById('retro-canvas');
      if (canvas) {
        const computedStyle = window.getComputedStyle(canvas);
        
        // Screen Resolution
        const screenRes = document.getElementById('screen-res');
        if (screenRes) screenRes.textContent = `${screen.width}√ó${screen.height}`;
        
        // Canvas Size
        const canvasSize = document.getElementById('canvas-size');
        if (canvasSize) canvasSize.textContent = `${canvas.width}√ó${canvas.height}`;
        
        // Expected Size
        const expectedSize = document.getElementById('expected-size');
        if (expectedSize) {
          const pixelScale = getPixelSize();
          const expectedW = (40 * 6 * pixelScale) + 20;
          const expectedH = (20 * 8 * pixelScale) + 20;
          expectedSize.textContent = `${expectedW}√ó${expectedH}`;
        }
        
        // Device Type Detection
        const deviceType = document.getElementById('device-type');
        if (deviceType) {
          deviceType.textContent = getDeviceInfo().type;
        }
        
        // Scale Factor
        const scaleFactor = document.getElementById('scale-factor');
        if (scaleFactor) {
          const dpr = window.devicePixelRatio || 1;
          const scaleX = canvas.offsetWidth / canvas.width;
          const scaleY = canvas.offsetHeight / canvas.height;
          scaleFactor.textContent = `DPR:${dpr} Display:${scaleX.toFixed(2)}√ó${scaleY.toFixed(2)}`;
        }
        
        // Pixel Scale
        const pixelScaleEl = document.getElementById('pixel-scale');
        if (pixelScaleEl) {
          const pixelScale = getPixelSize();
          pixelScaleEl.textContent = `${pixelScale}√ó${pixelScale}`;
        }
        
        // Max Width/Height - remove these
        const maxWidth = document.getElementById('max-width');
        const maxHeight = document.getElementById('max-height');
        if (maxWidth) maxWidth.textContent = computedStyle.maxWidth;
        if (maxHeight) maxHeight.textContent = computedStyle.maxHeight;
      }
    }
    
    // Update resolution immediately and on resize
    updateResolutionInfo();
    window.addEventListener('resize', updateResolutionInfo);
    
    // Also update after a short delay to catch canvas initialization
    setTimeout(updateResolutionInfo, 2000);
  </script>

  <script>
    // Debug ES6 module loading
    window.addEventListener('error', function(e) {
      console.error('Script error:', e.error, e.filename, e.lineno);
      document.getElementById('status-msg').textContent = 'System Status: ‚úó Script Error - ' + e.message;
      document.getElementById('status-msg').style.color = '#cc0000';
    });
    
    console.log('About to load TRS-80 main module...');
  </script>

  <script type="module" src="js/trs80-main.js"></script>
  
  <!-- Fallback non-module TRS-80 system for Kindle compatibility -->
  <script>
    console.log('Loading fallback TRS-80 system...');
    
    // TRS-80 Model 100 6x8 Font Data (subset for common characters)
    // ========================================
    // SHARED BASIC COMMAND PROCESSOR
    // Eliminates duplication between main system and SimpleTRS80
    // ========================================
    window.SharedBasicProcessor = {
      _vars: {}, // simple variable storage
      // Process BASIC commands using the provided display interface
      processCommand: function(cmd, parts, originalLine, program, displayInterface) {
        switch (cmd) {
          case 'PRINT':
            this.cmdPrint(originalLine, displayInterface);
            break;
          case 'LET':
            this.cmdAssignment(originalLine, displayInterface); // LET A=5
            break;
          case 'COLOR':
            this.cmdColor(parts[1], displayInterface);
            break;
          case 'CLS':
            displayInterface.clearScreen();
            break;
          case 'LIST':
            this.cmdList(program, displayInterface);
            break;
          case 'RUN':
            this.cmdRun(program, displayInterface);
            break;
          case 'NEW':
            this.cmdNew(program, displayInterface);
            break;
          default:
            // Check inline assignment without LET (e.g., A=10)
            if (/^[A-Z][A-Z0-9]*\s*=/.test(originalLine.trim().toUpperCase())) {
              this.cmdAssignment('LET ' + originalLine, displayInterface, true);
            } else {
              displayInterface.addText('?SYNTAX ERROR\n');
            }
            break;
        }
      },
      cmdAssignment: function(originalLine, displayInterface, silent) {
        // Normalize to remove LET if present
        let line = originalLine.replace(/^LET\s+/i,'').trim();
        const m = line.match(/^([A-Z][A-Z0-9]*)\s*=\s*(.*)$/i);
        if (!m) {
          if (!silent) displayInterface.addText('?SYNTAX ERROR\n');
          return;
        }
        const name = m[1].toUpperCase();
        let expr = m[2].trim();
        // Handle simple numeric or quoted string assignment only
        if (/^".*"$/.test(expr)) {
          this._vars[name] = expr.slice(1,-1);
        } else if (/^\d+$/.test(expr)) {
          this._vars[name] = parseInt(expr,10);
        } else if (/^[A-Z][A-Z0-9]*$/.test(expr)) {
          // variable to variable copy
            const src = expr.toUpperCase();
            this._vars[name] = this._vars[src];
        } else if (/^CHR\$\s*\(\s*\d+\s*\)$/i.test(expr)) {
            const code = parseInt(expr.match(/\d+/)[0],10);
            this._vars[name] = this.getCharacterByCode(code);
        } else {
          if (!silent) displayInterface.addText('?UNSUPPORTED EXPR\n');
          return;
        }
        if (!silent) displayInterface.addText('OK\n');
      },
      cmdPrint: function(originalLine, displayInterface) {
        const printMatch = originalLine.match(/^\s*print\s*(.*)/i);
        let text = printMatch ? printMatch[1] : originalLine.substring(5).trim();
        if (!text) { displayInterface.addText('\n'); return; }
        // Split by commas or semicolons retaining them to mimic BASIC list style
        const segments = text.split(/(?=,|;)|(?<=,|;)/);
        let output = '';
        for (let seg of segments) {
          seg = seg.trim();
          if (!seg) continue;
          if (seg === ',' || seg === ';') { // spacing control - minimal implementation
            output += ' ';
            continue;
          }
          // CHR$ inline
          const chrMatch = seg.match(/^CHR\$\s*\(\s*(\d+)\s*\)$/i);
          if (chrMatch) {
            output += this.getCharacterByCode(parseInt(chrMatch[1],10));
            continue;
          }
          // Quoted string literal only prints
          if (/^".*"$/.test(seg)) {
            output += seg.slice(1,-1);
            continue;
          }
          // Variable reference: do NOT print per requirement (treat as variable token)
          if (/^[A-Z][A-Z0-9]*$/.test(seg.toUpperCase())) {
            // intentionally skip output
            continue;
          }
          // Everything else ignored for now
        }
        displayInterface.addText(output + '\n');
      },
      cmdColor: function(colorArg, displayInterface) {
        const colorNum = parseInt(colorArg);
        if (!isNaN(colorNum) && colorNum >= 0 && colorNum <= 15) {
          displayInterface.setTextColor(colorNum);
        } else {
          displayInterface.addText('?SYNTAX ERROR - Color must be 0-15\n');
        }
      },
      
      cmdList: function(program, displayInterface) {
        const lineNumbers = Array.from(program.keys()).sort((a, b) => a - b);
        
        if (lineNumbers.length === 0) {
          displayInterface.addText('No program lines\n');
        } else {
          for (const lineNum of lineNumbers) {
            const command = program.get(lineNum);
            const line = lineNum + ' ' + command + '\n';
            displayInterface.addText(line);
          }
        }
      },
      
      cmdRun: function(program, displayInterface) {
        if (program.size === 0) {
          displayInterface.addText('No program to run\n');
          return;
        }
        
        const lineNumbers = Array.from(program.keys()).sort((a, b) => a - b);
        for (const lineNum of lineNumbers) {
          const command = program.get(lineNum);
          const runParts = command.trim().toUpperCase().split(/\s+/);
          const runCmd = runParts[0];
          
          if (runCmd === 'PRINT') {
            this.cmdPrint('PRINT ' + command.substring(5).trim(), displayInterface);
          } else if (runCmd === 'COLOR') {
            this.cmdColor(runParts[1], displayInterface);
          }
        }
      },
      
      // Unified line processing - handles both program lines and direct commands
      processLine: function(line, program, displayInterface) {
        const originalLine = line.trim();
        line = line.trim().toUpperCase();
        
        if (!line) return;
        
        // Check if line starts with a number (program line)
        const lineMatch = line.match(/^(\d+)\s*(.*)$/);
        if (lineMatch) {
          const lineNum = parseInt(lineMatch[1]);
          const command = lineMatch[2];
          
          if (command) {
            program.set(lineNum, command);
          } else {
            program.delete(lineNum);
          }
          return;
        }
        
        // Direct commands
        const parts = line.split(/\s+/);
        const cmd = parts[0];
        
        this.processCommand(cmd, parts, originalLine, program, displayInterface);
      },
      
      cmdNew: function(program, displayInterface) {
        program.clear();
        displayInterface.addText('Program cleared\n');
      },
      
      getCharacterByCode: function(code) {
        // For codes 1-31, return the actual character code as control characters
        if (code >= 1 && code <= 31) {
          return String.fromCharCode(code);
        }
        
        // For regular ASCII characters (32-126), return them normally
        if (code >= 32 && code <= 126) {
          return String.fromCharCode(code);
        }
        
        return '?'; // Unknown character
      }
    };

    // ========================================
    // SIMPLE TRS-80 DISPLAY SYSTEM (KINDLE FALLBACK)
    // ========================================
    
    // Simple TRS-80 Display System using real font data
    class SimpleTRS80 {
      constructor() {
        this.canvas = document.getElementById('retro-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.text = '';
        this.cursorPos = 0;
        
        // Use same pixel size function
        this.pixelSize = getPixelSize();
        console.log('SimpleTRS80: Using', this.pixelSize + '√ó' + this.pixelSize, 'pixel scaling');
        
        this.charWidth = 6 * this.pixelSize; // 6 pixels width, scaled
        this.charHeight = 8 * this.pixelSize; // 8 pixels height, scaled
        this.rows = [];
        this.colorRows = []; // Store color information for each position
        this.currentRow = 0;
        this.currentCol = 0;
        
        // Debug: Check if our math is right
        console.log('SimpleTRS80 DEBUG:');
        console.log('- Canvas size:', this.canvas.width, 'x', this.canvas.height);
        console.log('- Char size:', this.charWidth, 'x', this.charHeight);
        console.log('- Fits horizontally:', Math.floor(this.canvas.width / this.charWidth), 'chars');
        console.log('- Fits vertically:', Math.floor(this.canvas.height / this.charHeight), 'chars');
        
        // C64 color system
        this.currentTextColor = 14;  // Light Blue (default)
        this.currentBackgroundColor = -1; // Transparent (no background color)
        
        // Standard 8 ANSI colors (0-7) + C64 extended colors (8-15)
        this.C64_COLORS = {
          // Standard ANSI colors (0-7)
          0: '#000000', // Black
          1: '#AA0000', // Red  
          2: '#00AA00', // Green
          3: '#AA5500', // Yellow
          4: '#0000AA', // Blue
          5: '#AA00AA', // Magenta/Purple
          6: '#00AAAA', // Cyan
          7: '#AAAAAA', // White
          // Extended C64 colors (8-15) - keep original for compatibility
          8: '#6F4F25', 9: '#433900', 10: '#9A6759', 11: '#444444',
          12: '#6C6C6C', 13: '#9AD284', 14: '#6C5EB5', 15: '#959595'
        };
        
        // Initialize with empty rows - 40 chars wide to match TRS-80
        for (let i = 0; i < 20; i++) {
          this.rows[i] = '';
          this.colorRows[i] = new Array(40).fill({
            text: this.currentTextColor, 
            background: -1  // Transparent
          });
        }
        
        // Show BASIC startup message
        this.addChar('TRS-80 BASIC v1.0\n');
        this.addChar('Ready\n\n');
        
        this.render();
        
        // Start animation loop for blinking cursor
        setInterval(() => {
          this.render();
        }, 500);
      }
      
      addChar(char) {
        console.log('SimpleTRS80.addChar called with:', JSON.stringify(char));
        console.log('Current position: row', this.currentRow, 'col', this.currentCol);
        
        if (char === '\n' || char === 'Enter') {
          console.log('Processing newline/enter');
          this.currentRow++;
          this.currentCol = 0;
          if (this.currentRow >= 20) {
            // Scroll up
            this.rows.shift();
            this.colorRows.shift();
            this.rows.push('');
            this.colorRows.push(new Array(40).fill({
              text: this.currentTextColor, 
              background: -1  // Transparent
            }));
            this.currentRow = 19;
          }
        } else if (char === 'Backspace') {
          console.log('Processing backspace');
          if (this.currentCol > 0) {
            this.currentCol--;
            this.rows[this.currentRow] = this.rows[this.currentRow].slice(0, -1);
          } else if (this.currentRow > 0) {
            this.currentRow--;
            this.currentCol = this.rows[this.currentRow].length;
            this.rows[this.currentRow] = this.rows[this.currentRow].slice(0, -1);
          }
        } else if (char.length === 1) {
          console.log('Processing regular character:', JSON.stringify(char));
          // Regular character - store both char and color
          if (!this.rows[this.currentRow]) this.rows[this.currentRow] = '';
          if (!this.colorRows[this.currentRow]) {
            this.colorRows[this.currentRow] = new Array(40).fill({
              text: this.currentTextColor, 
              background: -1  // Transparent
            });
          }
          
          console.log('Before adding char - row content:', JSON.stringify(this.rows[this.currentRow]));
          this.rows[this.currentRow] += char;
          console.log('After adding char - row content:', JSON.stringify(this.rows[this.currentRow]));
          
          this.colorRows[this.currentRow][this.currentCol] = {
            text: this.currentTextColor,
            background: -1  // Transparent
          };
          
          this.currentCol++;
          if (this.currentCol >= 40) {
            this.currentRow++;
            this.currentCol = 0;
            if (this.currentRow >= 20) {
              this.rows.shift();
              this.colorRows.shift();
              this.rows.push('');
              this.colorRows.push(new Array(40).fill({
                text: this.currentTextColor, 
                background: -1  // Transparent
              }));
              this.currentRow = 19;
            }
          }
        }
        this.render();
      }
      
      render() {
        console.log('SimpleTRS80.render called');
        console.log('Current rows content:', this.rows.filter(r => r && r.length > 0));
        console.log('Current position: row', this.currentRow, 'col', this.currentCol);
        
        // Clear canvas with white background (Kindle-friendly)
        this.ctx.fillStyle = '#ffffff';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // No internal border - use CSS border only for maximum character space
        
        
        for (let row = 0; row < 20; row++) {
          const line = this.rows[row] || '';
          const colorLine = this.colorRows[row] || [];
          
          if (line.length > 0) {
            console.log(`Rendering row ${row}: "${line}"`);
          }
          
          for (let col = 0; col < line.length; col++) {
            const char = line[col];
            const colors = colorLine[col] || { text: this.currentTextColor, background: this.currentBackgroundColor };
            
            const x = 10 + (col * this.charWidth);  // 10px border
            const y = 10 + (row * this.charHeight);
            
            // Draw background color only if not transparent
            if (colors.background !== -1 && colors.background !== this.currentBackgroundColor) {
              this.ctx.fillStyle = this.C64_COLORS[colors.background];
              this.ctx.fillRect(x, y, this.charWidth, this.charHeight);
            }
            
            // Draw character with color
            this.drawPixelChar(char, col, row, colors.text);
          }
        }
        
        // Draw cursor
        this.drawCursor(this.currentCol, this.currentRow);
      }
      
      drawPixelChar(char, col, row, colorIndex = null) {
        const borderSize = 10;
        const x = borderSize + (col * this.charWidth);
        const y = borderSize + (row * this.charHeight);
        
        // Debug first few chars to see positioning
        if (char === '‚ò∫' || char === '\x01') {
          console.log(`Drawing smiley at col=${col}, row=${row} ‚Üí x=${x}, y=${y} (charWidth=${this.charWidth}, charHeight=${this.charHeight})`);
          console.log(`Canvas bounds: ${this.canvas.width}√ó${this.canvas.height}`);
          console.log(`Character bounds: x+width=${x + this.charWidth}, y+height=${y + this.charHeight}`);
        }
        
        // Use color from parameter or current text color
        const color = colorIndex !== null ? this.C64_COLORS[colorIndex] : this.C64_COLORS[this.currentTextColor];
        
        // Use original TRS-80 6x8 bitmap font data with color
        this.drawChar6x8(char, x, y, color);
      }
      
      drawCursor(col, row) {
        const borderSize = 10;
        const x = borderSize + (col * this.charWidth);
        const y = borderSize + (row * this.charHeight);
        
        // Blinking cursor - only show every other blink cycle
        if (Math.floor(Date.now() / 500) % 2) {
          this.ctx.fillStyle = '#000000';
          // Draw cursor as a solid block in the 6√ó8 area (full character cell)
          for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 6; c++) {
              this.ctx.fillRect(
                x + (c * this.pixelSize),
                y + (r * this.pixelSize),
                this.pixelSize,
                this.pixelSize
              );
            }
          }
        }
      }
      
      // Color control methods for Kindle compatibility
      setTextColor(colorIndex) {
        if (colorIndex >= 0 && colorIndex <= 15) {
          this.currentTextColor = colorIndex;
          console.log('SimpleTRS80: Text color set to', colorIndex, this.C64_COLORS[colorIndex]);
        }
      }
      
      setBackgroundColor(colorIndex) {
        if (colorIndex >= 0 && colorIndex <= 15) {
          this.currentBackgroundColor = colorIndex;
          console.log('SimpleTRS80: Background color set to', colorIndex, this.C64_COLORS[colorIndex]);
        }
      }
      
      // Clear screen - essential for CLS command
      clearScreen() {
        console.log('SimpleTRS80.clearScreen called');
        // Reset all rows to empty strings
        for (let i = 0; i < 20; i++) {
          this.rows[i] = '';
          this.colorRows[i] = new Array(40).fill({
            text: this.currentTextColor, 
            background: -1  // Transparent
          });
        }
        // Reset cursor position
        this.currentRow = 0;
        this.currentCol = 0;
        console.log('SimpleTRS80: Screen cleared, cursor reset to 0,0');
        this.render(); // Immediately refresh display
      }
      
      // Print text without newlines - convenience method for BASIC commands
      printText(text) {
        console.log('SimpleTRS80.printText called with:', JSON.stringify(text));
        for (let i = 0; i < text.length; i++) {
          console.log('printText: adding char', JSON.stringify(text[i]));
          this.addChar(text[i]);
        }
        console.log('printText: complete, current rows:', this.rows);
        this.render(); // Force a render after printing
      }
      
      // 6x8 font renderer with ES6 fallback
      drawChar6x8(char, x, y, color) {
        let charData;
        let rows = 8;
        let cols = 6; // logical columns

        if (window.trs80?.font?.FONT_DATA) {
          const code = char.charCodeAt(0);
          charData = window.trs80.font.FONT_DATA[code] || window.trs80.font.FONT_DATA[32];
        } else {
          const fontData = {
            '\x01': [0x3C, 0x42, 0xA5, 0x81, 0xA5, 0x99, 0x42, 0x3C],
            '\x02': [0x3C, 0x7E, 0xDB, 0xFF, 0xDB, 0xE7, 0x7E, 0x3C],
            '\x03': [0x6C, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00],
            ' ': [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],
            '!': [0x08,0x08,0x08,0x08,0x08,0x00,0x08,0x00],
            '"': [0x14,0x14,0x14,0x00,0x00,0x00,0x00,0x00],
            '#': [0x14,0x14,0x3E,0x14,0x3E,0x14,0x14,0x00],
            '$': [0x08,0x1E,0x28,0x1C,0x0A,0x3C,0x08,0x00],
            '%': [0x30,0x32,0x04,0x08,0x10,0x26,0x06,0x00],
            '&': [0x18,0x24,0x28,0x10,0x2A,0x24,0x1A,0x00],
            '\'': [0x08,0x08,0x10,0x00,0x00,0x00,0x00,0x00],
            '(': [0x04,0x08,0x10,0x10,0x10,0x08,0x04,0x00],
            ')': [0x10,0x08,0x04,0x04,0x04,0x08,0x10,0x00],
            '*': [0x00,0x08,0x2A,0x1C,0x2A,0x08,0x00,0x00],
            '+': [0x00,0x08,0x08,0x3E,0x08,0x08,0x00,0x00],
            ',': [0x00,0x00,0x00,0x00,0x18,0x18,0x10,0x00],
            '-': [0x00,0x00,0x00,0x3E,0x00,0x00,0x00,0x00],
            '.': [0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00],
            '/': [0x00,0x02,0x04,0x08,0x10,0x20,0x00,0x00]
          };
          charData = fontData[char] || fontData[char.toUpperCase()] || fontData[' '];
        }

        // Determine active bit width (some glyphs may use only 5 bits)
        let usedMask = 0;
        for (let r = 0; r < rows; r++) usedMask |= (charData[r] || 0);
        // If highest bit (bit 5 in 6-wide glyph) is never set but a lower bit is, shift left 1 to center
        const highestBit = 1 << (cols - 1); // 0b100000
        let adjustLeft = (usedMask & highestBit) === 0 && usedMask !== 0;

        // Special graphics (control range) keep original centering (they already are balanced)
        const code = char.charCodeAt(0);
        if (code >= 1 && code <= 3) adjustLeft = false;

        const leftOffset = adjustLeft ? this.pixelSize : 0;

        this.ctx.fillStyle = color;
        for (let row = 0; row < rows; row++) {
            const rowData = charData[row] || 0;
            for (let bit = 0; bit < cols; bit++) {
              // Test from MSB (bit 5) to LSB (bit 0) across 6 columns
              if (rowData & (1 << (cols - 1 - bit))) {
                const pixelX = x + leftOffset + bit * this.pixelSize;
                const pixelY = y + row * this.pixelSize;
                this.ctx.fillRect(pixelX, pixelY, this.pixelSize, this.pixelSize);
              }
            }
        }
      }
    }
    
    // ========================================
    // SYSTEM INITIALIZATION
    // ========================================
    
    // Simple unified initialization
    (function initSystem(){
      const canvas = document.getElementById('retro-canvas');
      const ctx = canvas.getContext('2d');
      window.simpleTRS80 = new SimpleTRS80();
      // existing diagnostic row logic remains
      if (!window._diagRowDrawn) {
        window._diagRowDrawn = true;
        for (let i = 0; i < 40; i++) { window.simpleTRS80.rows[0] += '\x01'; }
        window.simpleTRS80.render();
      }
      // Basic demo of variable rules:
      const di = {
        addText: t=>window.simpleTRS80.addChar(t),
        clearScreen: ()=>window.simpleTRS80.clearScreen(),
        setTextColor: c=>window.simpleTRS80.setTextColor(c)
      };
      const prog = new Map();
      const P = window.SharedBasicProcessor;
      P.processLine('LET A=5', prog, di);
      P.processLine('LET MSG="HELLO"', prog, di);
      P.processLine('PRINT A', prog, di);          // should print blank line
      P.processLine('PRINT "A="', prog, di);       // prints A=
      P.processLine('PRINT CHR$(1)', prog, di);     // prints smiley
      P.processLine('PRINT MSG', prog, di);         // suppressed
      P.processLine('PRINT "DONE"', prog, di);     // prints DONE
    })();

    // Simple unified initialization
    setTimeout(function() {
      console.log('=== Unified system initialization ===');
      
      // Initialize fallback display if ES6 modules didn't load
      if (!window.trs80) {
        console.log('‚ö† ES6 modules failed, initializing fallback display');
        window.simpleTRS80 = new SimpleTRS80();
        document.getElementById('status-msg').textContent = 'System Status: ‚úì Fallback Ready';
        document.getElementById('status-msg').style.color = '#ff8800';
      } else {
        console.log('‚úì ES6 modules loaded successfully');
        document.getElementById('status-msg').textContent = 'System Status: ‚úì Ready';
        document.getElementById('status-msg').style.color = '#006600';
      }
      
      // Show initial Apple IIe style prompt
      setTimeout(function() {
        // Only show prompt if ES6 modules didn't load (avoid double prompts)
        if (!window.trs80) {
          showPrompt();
        }
      }, 100);
      
      console.log('=== Unified system ready ===');
    }, 1000);
  </script>
</body>
</html>