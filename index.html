<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="cache-bust" content="v2025-09-24-2">
  <title>TRS-80 Model 100 Emulator - Updated 2025-09-24</title>
  <link rel="stylesheet" href="style.css">
</head>
<body style="background: #ffffff !important; color: #000000 !important;">
  <div id="retro-container" tabindex="0" style="background: #ffffff !important;">
    <canvas id="retro-canvas" style="background: #ffffff !important; border: 3px solid #000000 !important; cursor: text;"></canvas>
    
    <!-- Kindle Keyboard Input -->
    <input type="text" id="kindle-input" placeholder="Tap here to open Kindle keyboard and type..." 
           style="width: 100%; max-width: 500px; padding: 10px; margin: 10px 0; font-family: 'Courier New', monospace; font-size: 16px; border: 2px solid #000; border-radius: 3px;">
    
    <div style="font-size: 12px; color: #666; margin-top: 10px; text-align: center;">
      üí° <strong>Kindle Users:</strong> Type in the input box above - text will appear on TRS-80 screen<br>
      üé® <strong>Colors:</strong> Type @ then 1-8 for colors (Black,White,Red,Cyan,Purple,Green,Blue,Yellow)<br>
      üìù <strong>BASIC:</strong> Try: PRINT "HELLO", COLOR 4, PLOT 10,20, LINE 0,0,50,50, CLS<br>
      <span id="status-msg" style="color: #006600;">System Status: Loading...</span>
    </div>
    
    <script>
      // Simple resolution-based pixel size detection
      function getPixelSize() {
        const w = window.screen.width;
        const h = window.screen.height;
        
        // Specific device resolutions
        if (w === 636 && h === 848) return 2;  // Kindle ColorSoft
        if (w === 930 && h === 1240) return 3; // Kindle Scribe
        
        // General size categories
        if (w <= 768) return 2;  // Mobile devices
        return 4;                // Desktop/large screens
      }
      
      // Immediate canvas sizing - runs before modules load
      const canvas = document.getElementById('retro-canvas');
      const pixelSize = getPixelSize();
      console.log('Screen:', window.screen.width + '√ó' + window.screen.height, '‚Üí Pixel Size:', pixelSize + '√ó' + pixelSize);
      
      const width = (40 * 6 * pixelSize) + 20;
      const height = (20 * 8 * pixelSize) + 20;
      
      canvas.width = width;
      canvas.height = height;
      console.log('‚úì IMMEDIATE: Canvas set to', width + '√ó' + height);
      
      // Kindle Input Handler
      const kindleInput = document.getElementById('kindle-input');
      let inputBuffer = '';
      
      kindleInput.addEventListener('input', function(e) {
        const newValue = e.target.value;
        console.log('Input changed:', newValue);
        
        // Find what was added (handle typing and pasting)
        if (newValue.length > inputBuffer.length) {
          const addedText = newValue.slice(inputBuffer.length);
          console.log('Added text:', addedText);
          
          // Add each character to TRS-80
          for (let char of addedText) {
            if (window.trs80 && window.trs80.keyboard) {
              console.log('Sending to TRS-80:', char);
              console.log('Current window.trs80.keyboard.currentLine before processKeyInput:', JSON.stringify(window.trs80.keyboard.currentLine));
              // DO NOT modify currentLine here - let processKeyInput handle it
              window.trs80.keyboard.processKeyInput(char);
              console.log('Current window.trs80.keyboard.currentLine after processKeyInput:', JSON.stringify(window.trs80.keyboard.currentLine));
            } else {
              console.log('TRS-80 not ready, queuing:', char);
              // Queue for when system is ready
              window.pendingInput = window.pendingInput || [];
              window.pendingInput.push(char);
            }
          }
          
          if (window.trs80 && window.trs80.display) {
            window.trs80.display.render();
          }
        }
        
        // Clear the input field to prevent duplicate display
        setTimeout(() => {
          e.target.value = '';
          inputBuffer = '';
        }, 50);
        
        inputBuffer = newValue;
      });
      
      kindleInput.addEventListener('keydown', function(e) {
        console.log('Key pressed:', e.key);
        
        if (e.key === 'Backspace') {
          console.log('Processing backspace');
          if (window.trs80 && window.trs80.keyboard) {
            // Update current line
            if (window.trs80.keyboard.currentLine && window.trs80.keyboard.currentLine.length > 0) {
              window.trs80.keyboard.currentLine = window.trs80.keyboard.currentLine.slice(0, -1);
            }
            window.trs80.keyboard.processKeyInput('Backspace');
            window.trs80.display.render();
          }
          // Update our buffer
          inputBuffer = e.target.value.slice(0, -1);
          
        } else if (e.key === 'Enter') {
          console.log('=== ENTER KEY PRESSED ===');
          console.log('window.trs80 exists:', !!window.trs80);
          console.log('window.trs80.keyboard exists:', !!(window.trs80 && window.trs80.keyboard));
          
          // Check if this is the main system or fallback
          if (window.trs80 && window.trs80.keyboard && window.trs80.keyboard.processLine && typeof window.trs80.keyboard.processLine === 'function') {
            console.log('*** MAIN TRS-80 SYSTEM DETECTED - Using main system');
            if (window.trs80 && window.trs80.keyboard) {
              console.log('Current line value:', JSON.stringify(window.trs80.keyboard.currentLine));
              console.log('Current line length:', window.trs80.keyboard.currentLine ? window.trs80.keyboard.currentLine.length : 'undefined');
              console.log('Current line trimmed:', window.trs80.keyboard.currentLine ? JSON.stringify(window.trs80.keyboard.currentLine.trim()) : 'undefined');
              
              // Process as BASIC command if there's a current line
              if (window.trs80.keyboard.currentLine && window.trs80.keyboard.currentLine.trim()) {
                console.log('*** CALLING processLine with:', JSON.stringify(window.trs80.keyboard.currentLine));
                window.trs80.keyboard.processLine(window.trs80.keyboard.currentLine);
                console.log('*** processLine completed');
              } else {
                console.log('*** No line to process (empty or undefined)');
              }
              window.trs80.keyboard.currentLine = ''; // Reset line
              console.log('*** Line reset, calling processKeyInput(Enter)');
              window.trs80.keyboard.processKeyInput('Enter');
              window.trs80.display.render();
              console.log('*** Enter processing complete');
            }
          } else {
            console.log('*** FALLBACK SYSTEM DETECTED - Main system not available');
          }
          
          // Clear input and buffer
          e.target.value = '';
          inputBuffer = '';
          e.preventDefault();
        }
      });
      
      // Process any queued input when TRS-80 system is ready
      window.addEventListener('load', function() {
        setTimeout(function() {
          if (window.trs80 && window.trs80.keyboard && window.trs80.display) {
            console.log('‚úì TRS-80 system loaded successfully');
            document.getElementById('status-msg').textContent = 'System Status: ‚úì Ready for input';
            document.getElementById('status-msg').style.color = '#006600';
            
            if (window.pendingInput && window.pendingInput.length > 0) {
              console.log('Processing queued input:', window.pendingInput);
              for (let char of window.pendingInput) {
                window.trs80.keyboard.processKeyInput(char);
              }
              window.trs80.display.render();
              window.pendingInput = [];
            }
          } else {
            console.log('‚úó TRS-80 system failed to load');
            document.getElementById('status-msg').textContent = 'System Status: ‚úó Load Failed';
            document.getElementById('status-msg').style.color = '#cc0000';
          }
        }, 2000); // Wait 2 seconds for modules to load
      });
    </script>
    
    <div id="keyboard-area" style="background: #ffffff !important; color: #000000 !important;">
      <!-- Desktop Info -->
      <div id="desktop-info" style="margin-top: 15px; color: #000000 !important;">
        <p><strong>TRS-80 MODEL 100 - PORTABLE COMPUTER</strong></p>
        <p>Type anything ‚Ä¢ ENTER: new line ‚Ä¢ ESC: clear ‚Ä¢ BACKSPACE: delete ‚Ä¢ Arrow keys: navigate</p>
        <p>Resolution: <span id="resolution-info">Loading...</span></p>
        <div id="debug-info" style="margin-top: 10px; font-size: 10px; color: #666; font-family: monospace;">
          <div>Screen Resolution: <span id="screen-res">Loading...</span></div>
          <div>Canvas Size: <span id="canvas-size">Loading...</span></div>
          <div>Expected Size: <span id="expected-size">Loading...</span></div>
          <div>Device Type: <span id="device-type">Loading...</span></div>
          <div>Scale Factor: <span id="scale-factor">Loading...</span></div>
          <div>Pixel Scale: <span id="pixel-scale">Loading...</span></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    function updateResolutionInfo() {
      const resolutionInfo = document.getElementById('resolution-info');
      
      if (resolutionInfo) {
        const info = [
          `${window.innerWidth}√ó${window.innerHeight}`,
          `Screen: ${screen.width}√ó${screen.height}`,
          `DPR: ${window.devicePixelRatio || 1}`,
          `Touch: ${'ontouchstart' in window ? 'Yes' : 'No'}`
        ].join(' ‚Ä¢ ');
        resolutionInfo.textContent = info;
      }
      
      // Update individual debug fields
      const canvas = document.getElementById('retro-canvas');
      if (canvas) {
        const computedStyle = window.getComputedStyle(canvas);
        
        // Screen Resolution
        const screenRes = document.getElementById('screen-res');
        if (screenRes) screenRes.textContent = `${screen.width}√ó${screen.height}`;
        
        // Canvas Size
        const canvasSize = document.getElementById('canvas-size');
        if (canvasSize) canvasSize.textContent = `${canvas.width}√ó${canvas.height}`;
        
        // Expected Size
        const expectedSize = document.getElementById('expected-size');
        if (expectedSize) {
          const pixelScale = getPixelSize();
          const expectedW = (40 * 6 * pixelScale) + 20;
          const expectedH = (20 * 8 * pixelScale) + 20;
          expectedSize.textContent = `${expectedW}√ó${expectedH}`;
        }
        
        // Device Type Detection
        const deviceType = document.getElementById('device-type');
        if (deviceType) {
          const w = screen.width;
          const h = screen.height;
          let type = 'Desktop';
          
          if (w === 636 && h === 848) type = 'Kindle ColorSoft';
          else if (w === 930 && h === 1240) type = 'Kindle Scribe';  
          else if (w <= 768) type = 'Mobile';
          else if (w <= 1024) type = 'Tablet';
          
          deviceType.textContent = type;
        }
        
        // Scale Factor
        const scaleFactor = document.getElementById('scale-factor');
        if (scaleFactor) {
          const dpr = window.devicePixelRatio || 1;
          const scaleX = canvas.offsetWidth / canvas.width;
          const scaleY = canvas.offsetHeight / canvas.height;
          scaleFactor.textContent = `DPR:${dpr} Display:${scaleX.toFixed(2)}√ó${scaleY.toFixed(2)}`;
        }
        
        // Pixel Scale
        const pixelScaleEl = document.getElementById('pixel-scale');
        if (pixelScaleEl) {
          const pixelScale = getPixelSize();
          pixelScaleEl.textContent = `${pixelScale}√ó${pixelScale}`;
        }
        
        // Max Width/Height - remove these
        const maxWidth = document.getElementById('max-width');
        const maxHeight = document.getElementById('max-height');
        if (maxWidth) maxWidth.textContent = computedStyle.maxWidth;
        if (maxHeight) maxHeight.textContent = computedStyle.maxHeight;
      }
    }
    
    // Update resolution immediately and on resize
    updateResolutionInfo();
    window.addEventListener('resize', updateResolutionInfo);
    
    // Also update after a short delay to catch canvas initialization
    setTimeout(updateResolutionInfo, 2000);
  </script>

  <script>
    // Debug ES6 module loading
    window.addEventListener('error', function(e) {
      console.error('Script error:', e.error, e.filename, e.lineno);
      document.getElementById('status-msg').textContent = 'System Status: ‚úó Script Error - ' + e.message;
      document.getElementById('status-msg').style.color = '#cc0000';
    });
    
    console.log('About to load TRS-80 main module...');
  </script>

  <script type="module" src="js/trs80-main.js"></script>
  
  <!-- Fallback non-module TRS-80 system for Kindle compatibility -->
  <script>
    console.log('Loading fallback TRS-80 system...');
    
    // TRS-80 Model 100 5x7 Font Data (subset for common characters)
    const FONT_DATA = {
      ' ': [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
      '!': [0x04, 0x04, 0x04, 0x04, 0x00, 0x04, 0x00],
      '"': [0x0A, 0x0A, 0x0A, 0x00, 0x00, 0x00, 0x00],
      '#': [0x0A, 0x0A, 0x1F, 0x0A, 0x1F, 0x0A, 0x0A],
      '$': [0x04, 0x0F, 0x14, 0x0E, 0x05, 0x1E, 0x04],
      '%': [0x18, 0x19, 0x02, 0x04, 0x08, 0x13, 0x03],
      '&': [0x0C, 0x12, 0x14, 0x08, 0x15, 0x12, 0x0D],
      '\'': [0x0C, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00],
      '(': [0x02, 0x04, 0x08, 0x08, 0x08, 0x04, 0x02],
      ')': [0x08, 0x04, 0x02, 0x02, 0x02, 0x04, 0x08],
      '*': [0x00, 0x04, 0x15, 0x0E, 0x15, 0x04, 0x00],
      '+': [0x00, 0x04, 0x04, 0x1F, 0x04, 0x04, 0x00],
      ',': [0x00, 0x00, 0x00, 0x00, 0x0C, 0x04, 0x08],
      '-': [0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00],
      '.': [0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C],
      '/': [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x00],
      '0': [0x0E, 0x11, 0x13, 0x15, 0x19, 0x11, 0x0E],
      '1': [0x04, 0x0C, 0x04, 0x04, 0x04, 0x04, 0x0E],
      '2': [0x0E, 0x11, 0x01, 0x02, 0x04, 0x08, 0x1F],
      '3': [0x1F, 0x02, 0x04, 0x02, 0x01, 0x11, 0x0E],
      '4': [0x02, 0x06, 0x0A, 0x12, 0x1F, 0x02, 0x02],
      '5': [0x1F, 0x10, 0x1E, 0x01, 0x01, 0x11, 0x0E],
      '6': [0x06, 0x08, 0x10, 0x1E, 0x11, 0x11, 0x0E],
      '7': [0x1F, 0x01, 0x02, 0x04, 0x08, 0x08, 0x08],
      '8': [0x0E, 0x11, 0x11, 0x0E, 0x11, 0x11, 0x0E],
      '9': [0x0E, 0x11, 0x11, 0x0F, 0x01, 0x02, 0x0C],
      ':': [0x00, 0x0C, 0x0C, 0x00, 0x0C, 0x0C, 0x00],
      ';': [0x00, 0x0C, 0x0C, 0x00, 0x0C, 0x04, 0x08],
      '<': [0x02, 0x04, 0x08, 0x10, 0x08, 0x04, 0x02],
      '=': [0x00, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x00],
      '>': [0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08],
      '?': [0x0E, 0x11, 0x01, 0x02, 0x04, 0x00, 0x04],
      '@': [0x0E, 0x11, 0x01, 0x0D, 0x15, 0x15, 0x0E],
      'A': [0x0E, 0x11, 0x11, 0x11, 0x1F, 0x11, 0x11],
      'B': [0x1E, 0x11, 0x11, 0x1E, 0x11, 0x11, 0x1E],
      'C': [0x0E, 0x11, 0x10, 0x10, 0x10, 0x11, 0x0E],
      'D': [0x1C, 0x12, 0x11, 0x11, 0x11, 0x12, 0x1C],
      'E': [0x1F, 0x10, 0x10, 0x1E, 0x10, 0x10, 0x1F],
      'F': [0x1F, 0x10, 0x10, 0x1E, 0x10, 0x10, 0x10],
      'G': [0x0E, 0x11, 0x10, 0x17, 0x11, 0x11, 0x0F],
      'H': [0x11, 0x11, 0x11, 0x1F, 0x11, 0x11, 0x11],
      'I': [0x0E, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0E],
      'J': [0x07, 0x02, 0x02, 0x02, 0x02, 0x12, 0x0C],
      'K': [0x11, 0x12, 0x14, 0x18, 0x14, 0x12, 0x11],
      'L': [0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1F],
      'M': [0x11, 0x1B, 0x15, 0x15, 0x11, 0x11, 0x11],
      'N': [0x11, 0x11, 0x19, 0x15, 0x13, 0x11, 0x11],
      'O': [0x0E, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E],
      'P': [0x1E, 0x11, 0x11, 0x1E, 0x10, 0x10, 0x10],
      'Q': [0x0E, 0x11, 0x11, 0x15, 0x12, 0x0E, 0x01],
      'R': [0x1E, 0x11, 0x11, 0x1E, 0x14, 0x12, 0x11],
      'S': [0x0F, 0x10, 0x10, 0x0E, 0x01, 0x01, 0x1E],
      'T': [0x1F, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04],
      'U': [0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E],
      'V': [0x11, 0x11, 0x11, 0x11, 0x11, 0x0A, 0x04],
      'W': [0x11, 0x11, 0x11, 0x15, 0x15, 0x15, 0x0A],
      'X': [0x11, 0x11, 0x0A, 0x04, 0x0A, 0x11, 0x11],
      'Y': [0x11, 0x11, 0x11, 0x0A, 0x04, 0x04, 0x04],
      'Z': [0x1F, 0x01, 0x02, 0x04, 0x08, 0x10, 0x1F],
      'a': [0x00, 0x00, 0x0E, 0x01, 0x0F, 0x11, 0x0F],
      'b': [0x10, 0x10, 0x16, 0x19, 0x11, 0x11, 0x1E],
      'c': [0x00, 0x00, 0x0E, 0x10, 0x10, 0x11, 0x0E],
      'd': [0x01, 0x01, 0x0D, 0x13, 0x11, 0x11, 0x0F],
      'e': [0x00, 0x00, 0x0E, 0x11, 0x1F, 0x10, 0x0E],
      'f': [0x06, 0x09, 0x08, 0x1C, 0x08, 0x08, 0x08],
      'g': [0x00, 0x0F, 0x11, 0x0F, 0x01, 0x0E, 0x10],
      'h': [0x10, 0x10, 0x16, 0x19, 0x11, 0x11, 0x11],
      'i': [0x04, 0x00, 0x0C, 0x04, 0x04, 0x04, 0x0E],
      'j': [0x02, 0x00, 0x06, 0x02, 0x02, 0x12, 0x0C],
      'k': [0x10, 0x10, 0x12, 0x14, 0x18, 0x14, 0x12],
      'l': [0x0C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0E],
      'm': [0x00, 0x00, 0x1A, 0x15, 0x15, 0x11, 0x11],
      'n': [0x00, 0x00, 0x16, 0x19, 0x11, 0x11, 0x11],
      'o': [0x00, 0x00, 0x0E, 0x11, 0x11, 0x11, 0x0E],
      'p': [0x00, 0x00, 0x1E, 0x11, 0x1E, 0x10, 0x10],
      'q': [0x00, 0x00, 0x0D, 0x13, 0x0F, 0x01, 0x01],
      'r': [0x00, 0x00, 0x16, 0x19, 0x10, 0x10, 0x10],
      's': [0x00, 0x00, 0x0E, 0x10, 0x0E, 0x01, 0x1E],
      't': [0x08, 0x08, 0x1C, 0x08, 0x08, 0x09, 0x06],
      'u': [0x00, 0x00, 0x11, 0x11, 0x11, 0x13, 0x0D],
      'v': [0x00, 0x00, 0x11, 0x11, 0x11, 0x0A, 0x04],
      'w': [0x00, 0x00, 0x11, 0x11, 0x15, 0x15, 0x0A],
      'x': [0x00, 0x00, 0x11, 0x0A, 0x04, 0x0A, 0x11],
      'y': [0x00, 0x00, 0x11, 0x11, 0x0F, 0x01, 0x0E],
      'z': [0x00, 0x00, 0x1F, 0x02, 0x04, 0x08, 0x1F]
    };
    
    // Draw character using original TRS-80 bitmap font
    function drawChar(ctx, char, x, y, pixelSize, color) {
      const fontData = FONT_DATA[char];
      if (!fontData) return;
      
      ctx.fillStyle = color;
      
      for (let row = 0; row < 7; row++) {
        const rowData = fontData[row];
        for (let col = 0; col < 5; col++) {
          if (rowData & (1 << (4 - col))) {
            const pixelX = x + col * pixelSize;
            const pixelY = y + row * pixelSize;
            ctx.fillRect(pixelX, pixelY, pixelSize, pixelSize);
          }
        }
      }
    }
    
    // Simple TRS-80 Display System using real font data
    class SimpleTRS80 {
      constructor() {
        this.canvas = document.getElementById('retro-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.text = '';
        this.cursorPos = 0;
        
        // Use same pixel size function
        this.pixelSize = getPixelSize();
        console.log('SimpleTRS80: Using', this.pixelSize + '√ó' + this.pixelSize, 'pixel scaling');
        
        this.charWidth = 6 * this.pixelSize; // 5 pixels + 1 space, scaled
        this.charHeight = 8 * this.pixelSize; // 7 pixels + 1 space, scaled
        this.rows = [];
        this.colorRows = []; // Store color information for each position
        this.currentRow = 0;
        this.currentCol = 0;
        
        // C64 color system
        this.currentTextColor = 14;  // Light Blue (default)
        this.currentBackgroundColor = -1; // Transparent (no background color)
        
        // C64 Color palette (same as main system)
        this.C64_COLORS = {
          0: '#000000', 1: '#FFFFFF', 2: '#68372B', 3: '#70A4B2', 
          4: '#6F3D86', 5: '#588D43', 6: '#352879', 7: '#B8C76F',
          8: '#6F4F25', 9: '#433900', 10: '#9A6759', 11: '#444444',
          12: '#6C6C6C', 13: '#9AD284', 14: '#6C5EB5', 15: '#959595'
        };
        
        // Initialize with empty rows - 40 chars wide to match TRS-80
        for (let i = 0; i < 20; i++) {
          this.rows[i] = '';
          this.colorRows[i] = new Array(40).fill({
            text: this.currentTextColor, 
            background: -1  // Transparent
          });
        }
        
        // Show BASIC startup message
        this.addChar('TRS-80 BASIC v1.0\n');
        this.addChar('Ready\n\n');
        
        console.log('‚úì Simple TRS-80 initialized with BASIC');
        console.log(`Canvas: ${this.canvas.width}√ó${this.canvas.height}`);
        console.log(`Character cell: ${this.charWidth}√ó${this.charHeight} pixels`);
        console.log(`40 chars √ó ${this.charWidth} = ${40 * this.charWidth} pixels + 20 border = ${40 * this.charWidth + 20} total`);
        this.render();
        
        // Start animation loop for blinking cursor
        setInterval(() => {
          this.render();
        }, 500);
      }
      
      addChar(char) {
        console.log('SimpleTRS80.addChar called with:', JSON.stringify(char));
        console.log('Current position: row', this.currentRow, 'col', this.currentCol);
        
        if (char === '\n' || char === 'Enter') {
          console.log('Processing newline/enter');
          this.currentRow++;
          this.currentCol = 0;
          if (this.currentRow >= 20) {
            // Scroll up
            this.rows.shift();
            this.colorRows.shift();
            this.rows.push('');
            this.colorRows.push(new Array(40).fill({
              text: this.currentTextColor, 
              background: -1  // Transparent
            }));
            this.currentRow = 19;
          }
        } else if (char === 'Backspace') {
          console.log('Processing backspace');
          if (this.currentCol > 0) {
            this.currentCol--;
            this.rows[this.currentRow] = this.rows[this.currentRow].slice(0, -1);
          } else if (this.currentRow > 0) {
            this.currentRow--;
            this.currentCol = this.rows[this.currentRow].length;
            this.rows[this.currentRow] = this.rows[this.currentRow].slice(0, -1);
          }
        } else if (char.length === 1) {
          console.log('Processing regular character:', JSON.stringify(char));
          // Regular character - store both char and color
          if (!this.rows[this.currentRow]) this.rows[this.currentRow] = '';
          if (!this.colorRows[this.currentRow]) {
            this.colorRows[this.currentRow] = new Array(40).fill({
              text: this.currentTextColor, 
              background: -1  // Transparent
            });
          }
          
          console.log('Before adding char - row content:', JSON.stringify(this.rows[this.currentRow]));
          this.rows[this.currentRow] += char;
          console.log('After adding char - row content:', JSON.stringify(this.rows[this.currentRow]));
          
          this.colorRows[this.currentRow][this.currentCol] = {
            text: this.currentTextColor,
            background: -1  // Transparent
          };
          
          this.currentCol++;
          if (this.currentCol >= 40) {
            this.currentRow++;
            this.currentCol = 0;
            if (this.currentRow >= 20) {
              this.rows.shift();
              this.colorRows.shift();
              this.rows.push('');
              this.colorRows.push(new Array(40).fill({
                text: this.currentTextColor, 
                background: -1  // Transparent
              }));
              this.currentRow = 19;
            }
          }
        }
        this.render();
      }
      
      render() {
        console.log('SimpleTRS80.render called');
        console.log('Current rows content:', this.rows.filter(r => r && r.length > 0));
        console.log('Current position: row', this.currentRow, 'col', this.currentCol);
        
        // Clear canvas with white background (Kindle-friendly)
        this.ctx.fillStyle = '#ffffff';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw border
        this.ctx.strokeStyle = this.C64_COLORS[1]; // White border
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(1, 1, this.canvas.width-2, this.canvas.height-2);
        
        
        for (let row = 0; row < 20; row++) {
          const line = this.rows[row] || '';
          const colorLine = this.colorRows[row] || [];
          
          if (line.length > 0) {
            console.log(`Rendering row ${row}: "${line}"`);
          }
          
          for (let col = 0; col < line.length; col++) {
            const char = line[col];
            const colors = colorLine[col] || { text: this.currentTextColor, background: this.currentBackgroundColor };
            
            const x = 10 + (col * this.charWidth);  // 10px border
            const y = 10 + (row * this.charHeight);
            
            // Draw background color only if not transparent
            if (colors.background !== -1 && colors.background !== this.currentBackgroundColor) {
              this.ctx.fillStyle = this.C64_COLORS[colors.background];
              this.ctx.fillRect(x, y, this.charWidth, this.charHeight);
            }
            
            // Draw character with color
            this.drawPixelChar(char, col, row, colors.text);
          }
        }
        
        // Draw cursor
        this.drawCursor(this.currentCol, this.currentRow);
      }
      
      drawPixelChar(char, col, row, colorIndex = null) {
        const borderSize = 10;
        const x = borderSize + (col * this.charWidth);
        const y = borderSize + (row * this.charHeight);
        
        // Use color from parameter or current text color
        const color = colorIndex !== null ? this.C64_COLORS[colorIndex] : this.C64_COLORS[this.currentTextColor];
        
        // Use original TRS-80 5√ó7 bitmap font data with color
        this.drawChar5x7(char, x, y, color);
      }
      
      drawCursor(col, row) {
        const borderSize = 10;
        const x = borderSize + (col * this.charWidth);
        const y = borderSize + (row * this.charHeight);
        
        // Blinking cursor - only show every other blink cycle
        if (Math.floor(Date.now() / 500) % 2) {
          this.ctx.fillStyle = '#000000';
          // Draw cursor as a solid block in the 5√ó7 area (not the full cell)
          for (let r = 0; r < 7; r++) {
            for (let c = 0; c < 5; c++) {
              this.ctx.fillRect(
                x + (c * this.pixelSize),
                y + (r * this.pixelSize),
                this.pixelSize,
                this.pixelSize
              );
            }
          }
        }
      }
      
      // Color control methods for Kindle compatibility
      setTextColor(colorIndex) {
        if (colorIndex >= 0 && colorIndex <= 15) {
          this.currentTextColor = colorIndex;
          console.log('SimpleTRS80: Text color set to', colorIndex, this.C64_COLORS[colorIndex]);
        }
      }
      
      setBackgroundColor(colorIndex) {
        if (colorIndex >= 0 && colorIndex <= 15) {
          this.currentBackgroundColor = colorIndex;
          console.log('SimpleTRS80: Background color set to', colorIndex, this.C64_COLORS[colorIndex]);
        }
      }
      
      // Print text without newlines - convenience method for BASIC commands
      printText(text) {
        console.log('SimpleTRS80.printText called with:', JSON.stringify(text));
        for (let i = 0; i < text.length; i++) {
          console.log('printText: adding char', JSON.stringify(text[i]));
          this.addChar(text[i]);
        }
        console.log('printText: complete, current rows:', this.rows);
        this.render(); // Force a render after printing
      }
      
      // Simple 5x7 font renderer for Kindle compatibility
      drawChar5x7(char, x, y, color) {
        // Basic 5x7 font data for essential characters
        const fontData = {
          ' ': [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
          '!': [0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x04],
          '"': [0x0A, 0x0A, 0x0A, 0x00, 0x00, 0x00, 0x00],
          '#': [0x0A, 0x0A, 0x1F, 0x0A, 0x1F, 0x0A, 0x0A],
          '$': [0x04, 0x0F, 0x14, 0x0E, 0x05, 0x1E, 0x04],
          '%': [0x18, 0x19, 0x02, 0x04, 0x08, 0x13, 0x03],
          '&': [0x06, 0x09, 0x09, 0x06, 0x15, 0x09, 0x16],
          "'": [0x04, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00],
          '(': [0x02, 0x04, 0x08, 0x08, 0x08, 0x04, 0x02],
          ')': [0x08, 0x04, 0x02, 0x02, 0x02, 0x04, 0x08],
          '*': [0x00, 0x04, 0x15, 0x0E, 0x15, 0x04, 0x00],
          '+': [0x00, 0x04, 0x04, 0x1F, 0x04, 0x04, 0x00],
          ',': [0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x08],
          '-': [0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00],
          '.': [0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C],
          '/': [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x00],
          '0': [0x0E, 0x11, 0x13, 0x15, 0x19, 0x11, 0x0E],
          '1': [0x04, 0x0C, 0x04, 0x04, 0x04, 0x04, 0x0E],
          '2': [0x0E, 0x11, 0x01, 0x02, 0x04, 0x08, 0x1F],
          '3': [0x1F, 0x02, 0x04, 0x02, 0x01, 0x11, 0x0E],
          '4': [0x02, 0x06, 0x0A, 0x12, 0x1F, 0x02, 0x02],
          '5': [0x1F, 0x10, 0x1E, 0x01, 0x01, 0x11, 0x0E],
          '6': [0x06, 0x08, 0x10, 0x1E, 0x11, 0x11, 0x0E],
          '7': [0x1F, 0x01, 0x02, 0x04, 0x08, 0x08, 0x08],
          '8': [0x0E, 0x11, 0x11, 0x0E, 0x11, 0x11, 0x0E],
          '9': [0x0E, 0x11, 0x11, 0x0F, 0x01, 0x02, 0x0C],
          ':': [0x00, 0x0C, 0x0C, 0x00, 0x0C, 0x0C, 0x00],
          ';': [0x00, 0x0C, 0x0C, 0x00, 0x0C, 0x04, 0x08],
          '<': [0x02, 0x04, 0x08, 0x10, 0x08, 0x04, 0x02],
          '=': [0x00, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x00],
          '>': [0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08],
          '?': [0x0E, 0x11, 0x01, 0x02, 0x04, 0x00, 0x04],
          '@': [0x0E, 0x11, 0x01, 0x0D, 0x15, 0x15, 0x0E],
          'A': [0x0E, 0x11, 0x11, 0x11, 0x1F, 0x11, 0x11],
          'B': [0x1E, 0x11, 0x11, 0x1E, 0x11, 0x11, 0x1E],
          'C': [0x0E, 0x11, 0x10, 0x10, 0x10, 0x11, 0x0E],
          'D': [0x1C, 0x12, 0x11, 0x11, 0x11, 0x12, 0x1C],
          'E': [0x1F, 0x10, 0x10, 0x1E, 0x10, 0x10, 0x1F],
          'F': [0x1F, 0x10, 0x10, 0x1E, 0x10, 0x10, 0x10],
          'G': [0x0E, 0x11, 0x10, 0x17, 0x11, 0x11, 0x0F],
          'H': [0x11, 0x11, 0x11, 0x1F, 0x11, 0x11, 0x11],
          'I': [0x0E, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0E],
          'J': [0x07, 0x02, 0x02, 0x02, 0x02, 0x12, 0x0C],
          'K': [0x11, 0x12, 0x14, 0x18, 0x14, 0x12, 0x11],
          'L': [0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1F],
          'M': [0x11, 0x1B, 0x15, 0x15, 0x11, 0x11, 0x11],
          'N': [0x11, 0x11, 0x19, 0x15, 0x13, 0x11, 0x11],
          'O': [0x0E, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E],
          'P': [0x1E, 0x11, 0x11, 0x1E, 0x10, 0x10, 0x10],
          'Q': [0x0E, 0x11, 0x11, 0x15, 0x12, 0x0E, 0x01],
          'R': [0x1E, 0x11, 0x11, 0x1E, 0x14, 0x12, 0x11],
          'S': [0x0F, 0x10, 0x10, 0x0E, 0x01, 0x01, 0x1E],
          'T': [0x1F, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04],
          'U': [0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E],
          'V': [0x11, 0x11, 0x11, 0x11, 0x11, 0x0A, 0x04],
          'W': [0x11, 0x11, 0x11, 0x15, 0x15, 0x15, 0x0A],
          'X': [0x11, 0x11, 0x0A, 0x04, 0x0A, 0x11, 0x11],
          'Y': [0x11, 0x11, 0x11, 0x0A, 0x04, 0x04, 0x04],
          'Z': [0x1F, 0x01, 0x02, 0x04, 0x08, 0x10, 0x1F],
          'a': [0x00, 0x00, 0x0E, 0x01, 0x0F, 0x11, 0x0F],
          'b': [0x10, 0x10, 0x16, 0x19, 0x11, 0x11, 0x1E],
          'c': [0x00, 0x00, 0x0E, 0x10, 0x10, 0x11, 0x0E],
          'd': [0x01, 0x01, 0x0D, 0x13, 0x11, 0x11, 0x0F],
          'e': [0x00, 0x00, 0x0E, 0x11, 0x1F, 0x10, 0x0E],
          'f': [0x06, 0x09, 0x08, 0x1C, 0x08, 0x08, 0x08],
          'g': [0x00, 0x0F, 0x11, 0x0F, 0x01, 0x0E, 0x10],
          'h': [0x10, 0x10, 0x16, 0x19, 0x11, 0x11, 0x11],
          'i': [0x04, 0x00, 0x0C, 0x04, 0x04, 0x04, 0x0E],
          'j': [0x02, 0x00, 0x06, 0x02, 0x02, 0x12, 0x0C],
          'k': [0x10, 0x10, 0x12, 0x14, 0x18, 0x14, 0x12],
          'l': [0x0C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0E],
          'm': [0x00, 0x00, 0x1A, 0x15, 0x15, 0x11, 0x11],
          'n': [0x00, 0x00, 0x16, 0x19, 0x11, 0x11, 0x11],
          'o': [0x00, 0x00, 0x0E, 0x11, 0x11, 0x11, 0x0E],
          'p': [0x00, 0x00, 0x1E, 0x11, 0x1E, 0x10, 0x10],
          'q': [0x00, 0x00, 0x0D, 0x13, 0x0F, 0x01, 0x01],
          'r': [0x00, 0x00, 0x16, 0x19, 0x10, 0x10, 0x10],
          's': [0x00, 0x00, 0x0E, 0x10, 0x0E, 0x01, 0x1E],
          't': [0x08, 0x08, 0x1C, 0x08, 0x08, 0x09, 0x06],
          'u': [0x00, 0x00, 0x11, 0x11, 0x11, 0x13, 0x0D],
          'v': [0x00, 0x00, 0x11, 0x11, 0x11, 0x0A, 0x04],
          'w': [0x00, 0x00, 0x11, 0x11, 0x15, 0x15, 0x0A],
          'x': [0x00, 0x00, 0x11, 0x0A, 0x04, 0x0A, 0x11],
          'y': [0x00, 0x00, 0x11, 0x11, 0x0F, 0x01, 0x0E],
          'z': [0x00, 0x00, 0x1F, 0x02, 0x04, 0x08, 0x1F]
        };
        
        const charData = fontData[char.toUpperCase()] || fontData[' '];
        this.ctx.fillStyle = color;
        
        for (let row = 0; row < 7; row++) {
          const rowData = charData[row];
          for (let col = 0; col < 5; col++) {
            if (rowData & (1 << (4 - col))) {
              const pixelX = x + col * this.pixelSize;
              const pixelY = y + row * this.pixelSize;
              this.ctx.fillRect(pixelX, pixelY, this.pixelSize, this.pixelSize);
            }
          }
        }
      }
    }
    
    // Initialize fallback system if modules fail
    setTimeout(function() {
      if (!window.trs80) {
        console.log('‚ö† ES6 modules failed, using fallback system');
        window.simpleTRS80 = new SimpleTRS80();
        document.getElementById('status-msg').textContent = 'System Status: ‚úì Fallback Ready';
        document.getElementById('status-msg').style.color = '#ff8800';
        
        // Update input handlers to use simple system
        window.trs80 = {
          // Add program storage for fallback BASIC
          program: new Map(),
          variables: new Map(),
          
          keyboard: {
            currentLine: '',  // Add line tracking to fallback
            processKeyInput: function(char) {
              console.log('=== processKeyInput called with:', JSON.stringify(char));
              console.log('this.currentLine at start:', JSON.stringify(this.currentLine));
              
              // Handle special keys
              if (char === 'Backspace') {
                if (this.currentLine.length > 0) {
                  this.currentLine = this.currentLine.slice(0, -1);
                }
                console.log('Backspace - currentLine now:', JSON.stringify(this.currentLine));
                window.simpleTRS80.addChar(char);
                return;
              }
              
              if (char === 'Enter') {
                console.log('Enter - currentLine stays:', JSON.stringify(this.currentLine));
                window.simpleTRS80.addChar(char);
                return;
              }
              
              // Simple color system using Ctrl+Number or @Number
              // Since Kindle may not support Ctrl easily, use @ as color prefix
              if (char === '@') {
                console.log('Color mode activated - type 1-8 for colors');
                window.colorMode = true;
                // Don't add @ to display
                return;
              }
              
              // Handle color selection after @
              if (window.colorMode && char >= '1' && char <= '8') {
                const colorIndex = parseInt(char) - 1;
                const colors = [0, 1, 2, 3, 4, 5, 6, 7]; // Black, White, Red, Cyan, Purple, Green, Blue, Yellow
                window.simpleTRS80.setTextColor(colors[colorIndex]);
                window.colorMode = false;
                console.log('Color set to', colors[colorIndex]);
                return;
              }
              
              // Cancel color mode if any other key
              if (window.colorMode) {
                window.colorMode = false;
                console.log('Color mode cancelled');
              }
              
              // Regular character input - add to current line AND display
              if (char.length === 1) {
                console.log('Regular char - adding to currentLine:', JSON.stringify(char));
                this.currentLine += char;
                console.log('Character added to currentLine:', JSON.stringify(char));
                console.log('Current line now:', JSON.stringify(this.currentLine));
              }
              window.simpleTRS80.addChar(char);
              console.log('=== processKeyInput complete, currentLine:', JSON.stringify(this.currentLine));
            },
            processLine: function(line) {
              // Full BASIC command processing for fallback - enhanced version
              const originalLine = line.trim();
              line = line.trim().toUpperCase();
              console.log('Fallback BASIC processing:', line);
              if (!line) return;
              
              // Check if line starts with a number (program line)
              const lineMatch = line.match(/^(\d+)\s*(.*)$/);
              if (lineMatch) {
                const lineNum = parseInt(lineMatch[1]);
                const command = lineMatch[2];
                
                console.log('Program line detected:', lineNum, command);
                if (command) {
                  window.trs80.program.set(lineNum, command);
                  console.log('Stored line', lineNum, 'in program. Program now has', window.trs80.program.size, 'lines');
                  // Program lines stored silently like real BASIC
                } else {
                  window.trs80.program.delete(lineNum);
                  console.log('Deleted line', lineNum, 'from program');
                }
                return;
              }
              
              // Direct commands
              const parts = line.split(/\s+/);
              const cmd = parts[0];
              
              switch (cmd) {
                case 'PRINT':
                  // Use original line to preserve case and quotes
                  let text = originalLine.substring(5).trim(); // Remove 'PRINT' (case insensitive)
                  console.log('PRINT command with text:', text);
                  
                  if (!text) {
                    window.simpleTRS80.addChar('\n');
                    return;
                  }
                  
                  // Handle quoted strings
                  if (text.startsWith('"') && text.endsWith('"')) {
                    text = text.slice(1, -1);
                  } else if (text.startsWith("'") && text.endsWith("'")) {
                    text = text.slice(1, -1);
                  }
                  
                  // Add each character individually like main system
                  for (let i = 0; i < text.length; i++) {
                    window.simpleTRS80.addChar(text[i]);
                  }
                  window.simpleTRS80.addChar('\n');
                  break;
                  
                case 'COLOR':
                  const colorNum = parseInt(parts[1]);
                  console.log('COLOR command with number:', colorNum);
                  if (!isNaN(colorNum) && colorNum >= 0 && colorNum <= 15) {
                    window.simpleTRS80.setTextColor(colorNum);
                    const message = `Color set to ${colorNum}`;
                    for (let i = 0; i < message.length; i++) {
                      window.simpleTRS80.addChar(message[i]);
                    }
                    window.simpleTRS80.addChar('\n');
                  } else {
                    const message = '?SYNTAX ERROR - Color must be 0-15';
                    for (let i = 0; i < message.length; i++) {
                      window.simpleTRS80.addChar(message[i]);
                    }
                    window.simpleTRS80.addChar('\n');
                  }
                  break;
                  
                case 'CLS':
                  console.log('CLS command executing');
                  window.simpleTRS80.clearScreen();
                  break;
                  
                case 'LIST':
                  console.log('LIST command executing');
                  const lineNumbers = Array.from(window.trs80.program.keys()).sort((a, b) => a - b);
                  console.log('Program has', lineNumbers.length, 'lines:', lineNumbers);
                  
                  if (lineNumbers.length === 0) {
                    const message = 'No program lines';
                    for (let i = 0; i < message.length; i++) {
                      window.simpleTRS80.addChar(message[i]);
                    }
                    window.simpleTRS80.addChar('\n');
                  } else {
                    for (const lineNum of lineNumbers) {
                      const command = window.trs80.program.get(lineNum);
                      const line = `${lineNum} ${command}`;
                      console.log('Listing line:', line);
                      
                      // Add each character individually
                      for (let i = 0; i < line.length; i++) {
                        window.simpleTRS80.addChar(line[i]);
                      }
                      window.simpleTRS80.addChar('\n');
                    }
                  }
                  break;
                  
                case 'RUN':
                  console.log('RUN command executing');
                  if (window.trs80.program.size === 0) {
                    const message = 'No program to run';
                    for (let i = 0; i < message.length; i++) {
                      window.simpleTRS80.addChar(message[i]);
                    }
                    window.simpleTRS80.addChar('\n');
                  } else {
                    // Execute program lines in order
                    const lineNumbers = Array.from(window.trs80.program.keys()).sort((a, b) => a - b);
                    for (const lineNum of lineNumbers) {
                      const command = window.trs80.program.get(lineNum);
                      console.log('Executing line', lineNum + ':', command);
                      this.processLine(command); // Recursive call to execute command
                    }
                  }
                  break;
                  
                case 'NEW':
                  console.log('NEW command executing');
                  window.trs80.program.clear();
                  window.trs80.variables.clear();
                  const newMessage = 'Program cleared';
                  for (let i = 0; i < newMessage.length; i++) {
                    window.simpleTRS80.addChar(newMessage[i]);
                  }
                  window.simpleTRS80.addChar('\n');
                  break;
                  
                default:
                  console.log('Unknown command:', cmd);
                  const errorMessage = '?SYNTAX ERROR';
                  for (let i = 0; i < errorMessage.length; i++) {
                    window.simpleTRS80.addChar(errorMessage[i]);
                  }
                  window.simpleTRS80.addChar('\n');
                  break;
              }
            }
          },
          display: {
            render: function() {
              window.simpleTRS80.render();
            },
            setTextColor: function(colorIndex) {
              window.simpleTRS80.setTextColor(colorIndex);
            },
            setBackgroundColor: function(colorIndex) {  
              window.simpleTRS80.setBackgroundColor(colorIndex);
            }
          }
        };
      }
    }, 1000);
  </script>
</body>
</html>