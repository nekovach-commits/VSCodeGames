<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="cache-bust" content="v2025-09-24-2">
  <title>TRS-80 Model 100 Emulator - Updated 2025-09-24</title>
  <link rel="stylesheet" href="style.css">
</head>
<body style="background: #ffffff !important; color: #000000 !important;">
  <div id="retro-container" tabindex="0" style="background: #ffffff !important;">
    <canvas id="retro-canvas" style="background: #ffffff !important; border: 3px solid #000000 !important; cursor: text;"></canvas>
    
    <input type="text" id="kindle-input" placeholder="Tap here to open Kindle keyboard and type..." 
           style="width: 100%; max-width: 500px; padding: 10px; margin: 10px 0; font-family: 'Courier New', monospace; font-size: 16px; border: 2px solid #000; border-radius: 3px;">
    
    <div style="font-size: 12px; color: #666; margin-top: 10px; text-align: center;">
      üí° <strong>Kindle Users:</strong> Type in the input box above - text will appear on TRS-80 screen<br>
      üé® <strong>Colors:</strong> Use COLOR 0-7 (Black,Red,Green,Yellow,Blue,Magenta,Cyan,White)<br>
      üìù <strong>BASIC:</strong> Try: PRINT "HELLO", COLOR 1, COLOR 2, PRINT "GREEN TEXT"<br>
      <span id="status-msg" style="color: #006600;">System Status: Loading...</span>
    </div>
    
    <script>
      // ========================================
      // DEVICE DETECTION & PIXEL SCALING
      // ========================================
      
      // Unified device detection and pixel size calculation
      function getDeviceInfo() {
        const w = window.screen.width;
        const h = window.screen.height;
        
        // Specific device resolutions
        if (w === 636 && h === 848) return { type: 'Kindle ColorSoft', pixelSize: 2 };
        if (w === 930 && h === 1240) return { type: 'Kindle Scribe', pixelSize: 3 };
        
        // General size categories
        if (w <= 768) return { type: 'Mobile', pixelSize: 2 };
        if (w <= 1024) return { type: 'Tablet', pixelSize: 3 };
        return { type: 'Desktop', pixelSize: 4 };
      }
      
      function getPixelSize() {
        return getDeviceInfo().pixelSize;
      }
      
      // Immediate canvas sizing - runs before modules load
      const canvas = document.getElementById('retro-canvas');
      const pixelSize = getPixelSize();
      console.log('Screen:', window.screen.width + '√ó' + window.screen.height, '‚Üí Pixel Size:', pixelSize + '√ó' + pixelSize);
      
      const width = (40 * 6 * pixelSize) + 20;
      const height = (20 * 8 * pixelSize) + 20;
      
      canvas.width = width;
      canvas.height = height;
      console.log('‚úì IMMEDIATE: Canvas set to', width + '√ó' + height);
      
      // Kindle Input Handler
      const kindleInput = document.getElementById('kindle-input');
      // Unified input handling - works same way for all systems
      let currentLine = '';
      let inputBuffer = '';
      let showingPrompt = false;

      // ========================================
      // APPLE IIE STYLE PROMPT SYSTEM
      // ========================================
      
      function showPrompt() {
        if (!showingPrompt) {
          UnifiedDisplay.addChar(']');
          showingPrompt = true;
          UnifiedDisplay.render();
        }
      }
      
      function hidePrompt() {
        if (showingPrompt) {
          // Remove the ] character by sending backspace
          UnifiedDisplay.addChar('Backspace');
          showingPrompt = false;
          UnifiedDisplay.render();
        }
      }

      // ========================================
      // UNIFIED DISPLAY ABSTRACTION LAYER
      // ========================================
      
      // Helper function to get ES6 display if available
      function getES6Display() {
        return window.trs80 && window.trs80.display ? window.trs80.display : null;
      }
      
      // Universal display interface - auto-detects which backend to use
      const UnifiedDisplay = {
        addChar: function(char) {
          if (window.simpleTRS80) {
            window.simpleTRS80.addChar(char);
          } else {
            const es6Display = getES6Display();
            if (es6Display && es6Display.addChar) {
              es6Display.addChar(char);
            }
          }
        },
        clearScreen: function() {
          if (window.simpleTRS80) {
            window.simpleTRS80.clearScreen();
          } else {
            const es6Display = getES6Display();
            if (es6Display && es6Display.clearScreen) {
              es6Display.clearScreen();
            }
          }
        },
        setTextColor: function(colorIndex) {
          if (window.simpleTRS80) {
            window.simpleTRS80.setTextColor(colorIndex);
          } else {
            const es6Display = getES6Display();
            if (es6Display && es6Display.setTextColor) {
              es6Display.setTextColor(colorIndex);
            }
          }
        },
        addText: function(text) {
          for (let i = 0; i < text.length; i++) {
            this.addChar(text[i]);
          }
        },
        render: function() {
          const es6Display = getES6Display();
          if (es6Display && es6Display.render) {
            es6Display.render();
          }
          // SimpleTRS80 renders automatically
        }
      };

      // ========================================
      // UNIFIED PROGRAM STORAGE ABSTRACTION
      // ========================================
      
      // Universal program storage - auto-detects which storage to use
      const UnifiedProgram = {
        storage: null,
        getStorage: function() {
          if (!this.storage) {
            if (window.trs80 && window.trs80.program) {
              this.storage = window.trs80.program;
            } else {
              this.storage = new Map();
            }
          }
          return this.storage;
        },
        set: function(lineNum, command) {
          this.getStorage().set(lineNum, command);
        },
        get: function(lineNum) {
          return this.getStorage().get(lineNum);
        },
        delete: function(lineNum) {
          this.getStorage().delete(lineNum);
        },
        clear: function() {
          this.getStorage().clear();
        },
        keys: function() {
          return this.getStorage().keys();
        },
        get size() {
          return this.getStorage().size;
        }
      };

      // ========================================
      // UNIFIED INPUT PROCESSING
      // ========================================
      
      // Unified input processing
      function processCharacter(char) {
        if (char === 'Backspace') {
          // Only allow backspace if there are characters to delete (protect the ] prompt)
          if (currentLine.length > 0) {
            currentLine = currentLine.slice(0, -1);
            UnifiedDisplay.addChar(char);
          }
          return;
        }

        if (char === 'Enter') {
          // Don't hide prompt - just move to new line and let it naturally disappear
          
          // Add newline ONLY for SimpleTRS80 (Kindle) - ES6 system handles this internally
          if (window.simpleTRS80 && !window.trs80) {
            UnifiedDisplay.addChar('\n');
          }
          
          if (currentLine.trim()) {
            // Process through SharedBasicProcessor
            if (window.SharedBasicProcessor) {
              window.SharedBasicProcessor.processLine(currentLine.trim(), UnifiedProgram, UnifiedDisplay);
            }
          } else {
            // Empty line - just add newline and show prompt again
            if (window.simpleTRS80 && !window.trs80) {
              // Already added newline above for Kindle
            } else {
              UnifiedDisplay.addChar('\n');
            }
          }
          
          currentLine = ''; // Clear line
          showingPrompt = false; // Reset prompt state since we moved to new line
          showPrompt(); // Show prompt for next input
          UnifiedDisplay.render();
          return;
        }

        // Regular character - don't hide prompt when typing, just add characters after ]
        if (char.length === 1) {
          currentLine += char;
          UnifiedDisplay.addChar(char);
        }
        UnifiedDisplay.render();
      }
      
      // ========================================
      // INPUT EVENT HANDLERS
      // ========================================
      
      kindleInput.addEventListener('input', function(e) {
        const newValue = e.target.value;
        
        // Find what was added (handle typing and pasting)
        if (newValue.length > inputBuffer.length) {
          const addedText = newValue.slice(inputBuffer.length);
          // Process each character through unified system
          for (let char of addedText) {
            processCharacter(char);
          }
        }
        
        // Find what was removed (backspace)
        if (newValue.length < inputBuffer.length) {
          const removedCount = inputBuffer.length - newValue.length;
          for (let i = 0; i < removedCount; i++) {
            processCharacter('Backspace');
          }
        }
        
        // Clear the input field to prevent duplicate display
        setTimeout(() => {
          e.target.value = '';
          inputBuffer = '';
        }, 50);
        
        inputBuffer = newValue;
      });

      // Handle Enter key specifically for command execution
      kindleInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
          const currentInput = e.target.value.trim();
          if (currentInput) {
            // Set the current line and process Enter
            currentLine = currentInput;
            processCharacter('Enter');
          } else {
            processCharacter('Enter');
          }
          
          // Clear input field
          e.target.value = '';
          inputBuffer = '';
          e.preventDefault();
        } else if (e.key === 'Backspace') {
          // Handle backspace directly since input event might not fire reliably on Kindle
          if (currentLine.length > 0) {
            currentLine = currentLine.slice(0, -1);
            UnifiedDisplay.addChar('Backspace');
          }
        }
      });
    </script>
    
    <div id="keyboard-area" style="background: #ffffff !important; color: #000000 !important;">
      <!-- Desktop Info -->
      <div id="desktop-info" style="margin-top: 15px; color: #000000 !important;">
        <p><strong>TRS-80 MODEL 100 - PORTABLE COMPUTER</strong></p>
        <p>Type anything ‚Ä¢ ENTER: new line ‚Ä¢ ESC: clear ‚Ä¢ BACKSPACE: delete ‚Ä¢ Arrow keys: navigate</p>
        <p>Resolution: <span id="resolution-info">Loading...</span></p>
        <div id="debug-info" style="margin-top: 10px; font-size: 10px; color: #666; font-family: monospace;">
          <div>Screen Resolution: <span id="screen-res">Loading...</span></div>
          <div>Canvas Size: <span id="canvas-size">Loading...</span></div>
          <div>Expected Size: <span id="expected-size">Loading...</span></div>
          <div>Device Type: <span id="device-type">Loading...</span></div>
          <div>Scale Factor: <span id="scale-factor">Loading...</span></div>
          <div>Pixel Scale: <span id="pixel-scale">Loading...</span></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ========================================
    // RESOLUTION & DEVICE INFO FUNCTIONS
    // ========================================
    
    function updateResolutionInfo() {
      const resolutionInfo = document.getElementById('resolution-info');
      
      if (resolutionInfo) {
        const info = [
          `${window.innerWidth}√ó${window.innerHeight}`,
          `Screen: ${screen.width}√ó${screen.height}`,
          `DPR: ${window.devicePixelRatio || 1}`,
          `Touch: ${'ontouchstart' in window ? 'Yes' : 'No'}`
        ].join(' ‚Ä¢ ');
        resolutionInfo.textContent = info;
      }
      
      // Update individual debug fields
      const canvas = document.getElementById('retro-canvas');
      if (canvas) {
        const computedStyle = window.getComputedStyle(canvas);
        
        // Screen Resolution
        const screenRes = document.getElementById('screen-res');
        if (screenRes) screenRes.textContent = `${screen.width}√ó${screen.height}`;
        
        // Canvas Size
        const canvasSize = document.getElementById('canvas-size');
        if (canvasSize) canvasSize.textContent = `${canvas.width}√ó${canvas.height}`;
        
        // Expected Size
        const expectedSize = document.getElementById('expected-size');
        if (expectedSize) {
          const pixelScale = getPixelSize();
          const expectedW = (40 * 6 * pixelScale) + 20;
          const expectedH = (20 * 8 * pixelScale) + 20;
          expectedSize.textContent = `${expectedW}√ó${expectedH}`;
        }
        
        // Device Type Detection
        const deviceType = document.getElementById('device-type');
        if (deviceType) {
          deviceType.textContent = getDeviceInfo().type;
        }
        
        // Scale Factor
        const scaleFactor = document.getElementById('scale-factor');
        if (scaleFactor) {
          const dpr = window.devicePixelRatio || 1;
          const scaleX = canvas.offsetWidth / canvas.width;
          const scaleY = canvas.offsetHeight / canvas.height;
          scaleFactor.textContent = `DPR:${dpr} Display:${scaleX.toFixed(2)}√ó${scaleY.toFixed(2)}`;
        }
        
        // Pixel Scale
        const pixelScaleEl = document.getElementById('pixel-scale');
        if (pixelScaleEl) {
          const pixelScale = getPixelSize();
          pixelScaleEl.textContent = `${pixelScale}√ó${pixelScale}`;
        }
        
        // Max Width/Height - remove these
        const maxWidth = document.getElementById('max-width');
        const maxHeight = document.getElementById('max-height');
        if (maxWidth) maxWidth.textContent = computedStyle.maxWidth;
        if (maxHeight) maxHeight.textContent = computedStyle.maxHeight;
      }
    }
    
    // Update resolution immediately and on resize
    updateResolutionInfo();
    window.addEventListener('resize', updateResolutionInfo);
    
    // Also update after a short delay to catch canvas initialization
    setTimeout(updateResolutionInfo, 2000);
  </script>

  <script>
    // Debug ES6 module loading
    window.addEventListener('error', function(e) {
      console.error('Script error:', e.error, e.filename, e.lineno);
      document.getElementById('status-msg').textContent = 'System Status: ‚úó Script Error - ' + e.message;
      document.getElementById('status-msg').style.color = '#cc0000';
    });
    
    console.log('About to load TRS-80 main module...');
  </script>

  <script type="module" src="js/trs80-main.js"></script>
  
  <!-- Fallback non-module TRS-80 system for Kindle compatibility -->
  <script>
    console.log('Loading fallback TRS-80 system...');
    
    // TRS-80 Model 100 5x7 Font Data (subset for common characters)
    const FONT_DATA = {
      ' ': [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
      '!': [0x04, 0x04, 0x04, 0x04, 0x00, 0x04, 0x00],
      '"': [0x0A, 0x0A, 0x0A, 0x00, 0x00, 0x00, 0x00],
      '#': [0x0A, 0x0A, 0x1F, 0x0A, 0x1F, 0x0A, 0x0A],
      '$': [0x04, 0x0F, 0x14, 0x0E, 0x05, 0x1E, 0x04],
      '%': [0x18, 0x19, 0x02, 0x04, 0x08, 0x13, 0x03],
      '&': [0x0C, 0x12, 0x14, 0x08, 0x15, 0x12, 0x0D],
      '\'': [0x0C, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00],
      '(': [0x02, 0x04, 0x08, 0x08, 0x08, 0x04, 0x02],
      ')': [0x08, 0x04, 0x02, 0x02, 0x02, 0x04, 0x08],
      '*': [0x00, 0x04, 0x15, 0x0E, 0x15, 0x04, 0x00],
      '+': [0x00, 0x04, 0x04, 0x1F, 0x04, 0x04, 0x00],
      ',': [0x00, 0x00, 0x00, 0x00, 0x0C, 0x04, 0x08],
      '-': [0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00],
      '.': [0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C],
      '/': [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x00],
      '0': [0x0E, 0x11, 0x13, 0x15, 0x19, 0x11, 0x0E],
      '1': [0x04, 0x0C, 0x04, 0x04, 0x04, 0x04, 0x0E],
      '2': [0x0E, 0x11, 0x01, 0x02, 0x04, 0x08, 0x1F],
      '3': [0x1F, 0x02, 0x04, 0x02, 0x01, 0x11, 0x0E],
      '4': [0x02, 0x06, 0x0A, 0x12, 0x1F, 0x02, 0x02],
      '5': [0x1F, 0x10, 0x1E, 0x01, 0x01, 0x11, 0x0E],
      '6': [0x06, 0x08, 0x10, 0x1E, 0x11, 0x11, 0x0E],
      '7': [0x1F, 0x01, 0x02, 0x04, 0x08, 0x08, 0x08],
      '8': [0x0E, 0x11, 0x11, 0x0E, 0x11, 0x11, 0x0E],
      '9': [0x0E, 0x11, 0x11, 0x0F, 0x01, 0x02, 0x0C],
      ':': [0x00, 0x0C, 0x0C, 0x00, 0x0C, 0x0C, 0x00],
      ';': [0x00, 0x0C, 0x0C, 0x00, 0x0C, 0x04, 0x08],
      '<': [0x02, 0x04, 0x08, 0x10, 0x08, 0x04, 0x02],
      '=': [0x00, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x00],
      '>': [0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08],
      '?': [0x0E, 0x11, 0x01, 0x02, 0x04, 0x00, 0x04],
      '@': [0x0E, 0x11, 0x01, 0x0D, 0x15, 0x15, 0x0E],
      'A': [0x0E, 0x11, 0x11, 0x11, 0x1F, 0x11, 0x11],
      'B': [0x1E, 0x11, 0x11, 0x1E, 0x11, 0x11, 0x1E],
      'C': [0x0E, 0x11, 0x10, 0x10, 0x10, 0x11, 0x0E],
      'D': [0x1C, 0x12, 0x11, 0x11, 0x11, 0x12, 0x1C],
      'E': [0x1F, 0x10, 0x10, 0x1E, 0x10, 0x10, 0x1F],
      'F': [0x1F, 0x10, 0x10, 0x1E, 0x10, 0x10, 0x10],
      'G': [0x0E, 0x11, 0x10, 0x17, 0x11, 0x11, 0x0F],
      'H': [0x11, 0x11, 0x11, 0x1F, 0x11, 0x11, 0x11],
      'I': [0x0E, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0E],
      'J': [0x07, 0x02, 0x02, 0x02, 0x02, 0x12, 0x0C],
      'K': [0x11, 0x12, 0x14, 0x18, 0x14, 0x12, 0x11],
      'L': [0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1F],
      'M': [0x11, 0x1B, 0x15, 0x15, 0x11, 0x11, 0x11],
      'N': [0x11, 0x11, 0x19, 0x15, 0x13, 0x11, 0x11],
      'O': [0x0E, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E],
      'P': [0x1E, 0x11, 0x11, 0x1E, 0x10, 0x10, 0x10],
      'Q': [0x0E, 0x11, 0x11, 0x15, 0x12, 0x0E, 0x01],
      'R': [0x1E, 0x11, 0x11, 0x1E, 0x14, 0x12, 0x11],
      'S': [0x0F, 0x10, 0x10, 0x0E, 0x01, 0x01, 0x1E],
      'T': [0x1F, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04],
      'U': [0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E],
      'V': [0x11, 0x11, 0x11, 0x11, 0x11, 0x0A, 0x04],
      'W': [0x11, 0x11, 0x11, 0x15, 0x15, 0x15, 0x0A],
      'X': [0x11, 0x11, 0x0A, 0x04, 0x0A, 0x11, 0x11],
      'Y': [0x11, 0x11, 0x11, 0x0A, 0x04, 0x04, 0x04],
      'Z': [0x1F, 0x01, 0x02, 0x04, 0x08, 0x10, 0x1F],
      'a': [0x00, 0x00, 0x0E, 0x01, 0x0F, 0x11, 0x0F],
      'b': [0x10, 0x10, 0x16, 0x19, 0x11, 0x11, 0x1E],
      'c': [0x00, 0x00, 0x0E, 0x10, 0x10, 0x11, 0x0E],
      'd': [0x01, 0x01, 0x0D, 0x13, 0x11, 0x11, 0x0F],
      'e': [0x00, 0x00, 0x0E, 0x11, 0x1F, 0x10, 0x0E],
      'f': [0x06, 0x09, 0x08, 0x1C, 0x08, 0x08, 0x08],
      'g': [0x00, 0x0F, 0x11, 0x0F, 0x01, 0x0E, 0x10],
      'h': [0x10, 0x10, 0x16, 0x19, 0x11, 0x11, 0x11],
      'i': [0x04, 0x00, 0x0C, 0x04, 0x04, 0x04, 0x0E],
      'j': [0x02, 0x00, 0x06, 0x02, 0x02, 0x12, 0x0C],
      'k': [0x10, 0x10, 0x12, 0x14, 0x18, 0x14, 0x12],
      'l': [0x0C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0E],
      'm': [0x00, 0x00, 0x1A, 0x15, 0x15, 0x11, 0x11],
      'n': [0x00, 0x00, 0x16, 0x19, 0x11, 0x11, 0x11],
      'o': [0x00, 0x00, 0x0E, 0x11, 0x11, 0x11, 0x0E],
      'p': [0x00, 0x00, 0x1E, 0x11, 0x1E, 0x10, 0x10],
      'q': [0x00, 0x00, 0x0D, 0x13, 0x0F, 0x01, 0x01],
      'r': [0x00, 0x00, 0x16, 0x19, 0x10, 0x10, 0x10],
      's': [0x00, 0x00, 0x0E, 0x10, 0x0E, 0x01, 0x1E],
      't': [0x08, 0x08, 0x1C, 0x08, 0x08, 0x09, 0x06],
      'u': [0x00, 0x00, 0x11, 0x11, 0x11, 0x13, 0x0D],
      'v': [0x00, 0x00, 0x11, 0x11, 0x11, 0x0A, 0x04],
      'w': [0x00, 0x00, 0x11, 0x11, 0x15, 0x15, 0x0A],
      'x': [0x00, 0x00, 0x11, 0x0A, 0x04, 0x0A, 0x11],
      'y': [0x00, 0x00, 0x11, 0x11, 0x0F, 0x01, 0x0E],
      'z': [0x00, 0x00, 0x1F, 0x02, 0x04, 0x08, 0x1F]
    };
    
    // Draw character using original TRS-80 bitmap font
    function drawChar(ctx, char, x, y, pixelSize, color) {
      const fontData = FONT_DATA[char];
      if (!fontData) return;
      
      ctx.fillStyle = color;
      
      for (let row = 0; row < 7; row++) {
        const rowData = fontData[row];
        for (let col = 0; col < 5; col++) {
          if (rowData & (1 << (4 - col))) {
            const pixelX = x + col * pixelSize;
            const pixelY = y + row * pixelSize;
            ctx.fillRect(pixelX, pixelY, pixelSize, pixelSize);
          }
        }
      }
    }
    
    // ========================================
    // SHARED BASIC COMMAND PROCESSOR
    // Eliminates duplication between main system and SimpleTRS80
    // ========================================
    window.SharedBasicProcessor = {
      // Process BASIC commands using the provided display interface
      processCommand: function(cmd, parts, originalLine, program, displayInterface) {
        switch (cmd) {
          case 'PRINT':
            this.cmdPrint(originalLine, displayInterface);
            break;
            
          case 'COLOR':
            this.cmdColor(parts[1], displayInterface);
            break;
            
          case 'CLS':
            displayInterface.clearScreen();
            break;
            
          case 'LIST':
            this.cmdList(program, displayInterface);
            break;
            
          case 'RUN':
            this.cmdRun(program, displayInterface);
            break;
            
          case 'NEW':
            this.cmdNew(program, displayInterface);
            break;
            
          default:
            displayInterface.addText('?SYNTAX ERROR\n');
            break;
        }
      },
      
      cmdPrint: function(originalLine, displayInterface) {
        const printMatch = originalLine.match(/^\s*print\s*(.*)/i);
        let text = printMatch ? printMatch[1] : originalLine.substring(5).trim();
        
        if (!text) {
          displayInterface.addText('\n');
          return;
        }
        
        // Handle quoted strings
        if (text.startsWith('"') && text.endsWith('"')) {
          text = text.slice(1, -1);
        } else if (text.startsWith("'") && text.endsWith("'")) {
          text = text.slice(1, -1);
        }
        
        displayInterface.addText(text + '\n');
      },
      
      cmdColor: function(colorArg, displayInterface) {
        const colorNum = parseInt(colorArg);
        if (!isNaN(colorNum) && colorNum >= 0 && colorNum <= 15) {
          displayInterface.setTextColor(colorNum);
        } else {
          displayInterface.addText('?SYNTAX ERROR - Color must be 0-15\n');
        }
      },
      
      cmdList: function(program, displayInterface) {
        const lineNumbers = Array.from(program.keys()).sort((a, b) => a - b);
        
        if (lineNumbers.length === 0) {
          displayInterface.addText('No program lines\n');
        } else {
          for (const lineNum of lineNumbers) {
            const command = program.get(lineNum);
            const line = lineNum + ' ' + command + '\n';
            displayInterface.addText(line);
          }
        }
      },
      
      cmdRun: function(program, displayInterface) {
        if (program.size === 0) {
          displayInterface.addText('No program to run\n');
          return;
        }
        
        const lineNumbers = Array.from(program.keys()).sort((a, b) => a - b);
        for (const lineNum of lineNumbers) {
          const command = program.get(lineNum);
          const runParts = command.trim().toUpperCase().split(/\s+/);
          const runCmd = runParts[0];
          
          if (runCmd === 'PRINT') {
            this.cmdPrint('PRINT ' + command.substring(5).trim(), displayInterface);
          } else if (runCmd === 'COLOR') {
            this.cmdColor(runParts[1], displayInterface);
          }
        }
      },
      
      // Unified line processing - handles both program lines and direct commands
      processLine: function(line, program, displayInterface) {
        const originalLine = line.trim();
        line = line.trim().toUpperCase();
        
        if (!line) return;
        
        // Check if line starts with a number (program line)
        const lineMatch = line.match(/^(\d+)\s*(.*)$/);
        if (lineMatch) {
          const lineNum = parseInt(lineMatch[1]);
          const command = lineMatch[2];
          
          if (command) {
            program.set(lineNum, command);
          } else {
            program.delete(lineNum);
          }
          return;
        }
        
        // Direct commands
        const parts = line.split(/\s+/);
        const cmd = parts[0];
        
        this.processCommand(cmd, parts, originalLine, program, displayInterface);
      },
      
      cmdNew: function(program, displayInterface) {
        program.clear();
        displayInterface.addText('Program cleared\n');
      }
    };

    // ========================================
    // SIMPLE TRS-80 DISPLAY SYSTEM (KINDLE FALLBACK)
    // ========================================
    
    // Simple TRS-80 Display System using real font data
    class SimpleTRS80 {
      constructor() {
        this.canvas = document.getElementById('retro-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.text = '';
        this.cursorPos = 0;
        
        // Use same pixel size function
        this.pixelSize = getPixelSize();
        console.log('SimpleTRS80: Using', this.pixelSize + '√ó' + this.pixelSize, 'pixel scaling');
        
        this.charWidth = 6 * this.pixelSize; // 5 pixels + 1 space, scaled
        this.charHeight = 8 * this.pixelSize; // 7 pixels + 1 space, scaled
        this.rows = [];
        this.colorRows = []; // Store color information for each position
        this.currentRow = 0;
        this.currentCol = 0;
        
        // C64 color system
        this.currentTextColor = 14;  // Light Blue (default)
        this.currentBackgroundColor = -1; // Transparent (no background color)
        
        // Standard 8 ANSI colors (0-7) + C64 extended colors (8-15)
        this.C64_COLORS = {
          // Standard ANSI colors (0-7)
          0: '#000000', // Black
          1: '#AA0000', // Red  
          2: '#00AA00', // Green
          3: '#AA5500', // Yellow
          4: '#0000AA', // Blue
          5: '#AA00AA', // Magenta/Purple
          6: '#00AAAA', // Cyan
          7: '#AAAAAA', // White
          // Extended C64 colors (8-15) - keep original for compatibility
          8: '#6F4F25', 9: '#433900', 10: '#9A6759', 11: '#444444',
          12: '#6C6C6C', 13: '#9AD284', 14: '#6C5EB5', 15: '#959595'
        };
        
        // Initialize with empty rows - 40 chars wide to match TRS-80
        for (let i = 0; i < 20; i++) {
          this.rows[i] = '';
          this.colorRows[i] = new Array(40).fill({
            text: this.currentTextColor, 
            background: -1  // Transparent
          });
        }
        
        // Show BASIC startup message
        this.addChar('TRS-80 BASIC v1.0\n');
        this.addChar('Ready\n\n');
        
        console.log('‚úì Simple TRS-80 initialized with BASIC');
        console.log(`Canvas: ${this.canvas.width}√ó${this.canvas.height}`);
        console.log(`Character cell: ${this.charWidth}√ó${this.charHeight} pixels`);
        console.log(`40 chars √ó ${this.charWidth} = ${40 * this.charWidth} pixels + 20 border = ${40 * this.charWidth + 20} total`);
        this.render();
        
        // Start animation loop for blinking cursor
        setInterval(() => {
          this.render();
        }, 500);
      }
      
      addChar(char) {
        console.log('SimpleTRS80.addChar called with:', JSON.stringify(char));
        console.log('Current position: row', this.currentRow, 'col', this.currentCol);
        
        if (char === '\n' || char === 'Enter') {
          console.log('Processing newline/enter');
          this.currentRow++;
          this.currentCol = 0;
          if (this.currentRow >= 20) {
            // Scroll up
            this.rows.shift();
            this.colorRows.shift();
            this.rows.push('');
            this.colorRows.push(new Array(40).fill({
              text: this.currentTextColor, 
              background: -1  // Transparent
            }));
            this.currentRow = 19;
          }
        } else if (char === 'Backspace') {
          console.log('Processing backspace');
          if (this.currentCol > 0) {
            this.currentCol--;
            this.rows[this.currentRow] = this.rows[this.currentRow].slice(0, -1);
          } else if (this.currentRow > 0) {
            this.currentRow--;
            this.currentCol = this.rows[this.currentRow].length;
            this.rows[this.currentRow] = this.rows[this.currentRow].slice(0, -1);
          }
        } else if (char.length === 1) {
          console.log('Processing regular character:', JSON.stringify(char));
          // Regular character - store both char and color
          if (!this.rows[this.currentRow]) this.rows[this.currentRow] = '';
          if (!this.colorRows[this.currentRow]) {
            this.colorRows[this.currentRow] = new Array(40).fill({
              text: this.currentTextColor, 
              background: -1  // Transparent
            });
          }
          
          console.log('Before adding char - row content:', JSON.stringify(this.rows[this.currentRow]));
          this.rows[this.currentRow] += char;
          console.log('After adding char - row content:', JSON.stringify(this.rows[this.currentRow]));
          
          this.colorRows[this.currentRow][this.currentCol] = {
            text: this.currentTextColor,
            background: -1  // Transparent
          };
          
          this.currentCol++;
          if (this.currentCol >= 40) {
            this.currentRow++;
            this.currentCol = 0;
            if (this.currentRow >= 20) {
              this.rows.shift();
              this.colorRows.shift();
              this.rows.push('');
              this.colorRows.push(new Array(40).fill({
                text: this.currentTextColor, 
                background: -1  // Transparent
              }));
              this.currentRow = 19;
            }
          }
        }
        this.render();
      }
      
      render() {
        console.log('SimpleTRS80.render called');
        console.log('Current rows content:', this.rows.filter(r => r && r.length > 0));
        console.log('Current position: row', this.currentRow, 'col', this.currentCol);
        
        // Clear canvas with white background (Kindle-friendly)
        this.ctx.fillStyle = '#ffffff';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw border
        this.ctx.strokeStyle = this.C64_COLORS[1]; // White border
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(1, 1, this.canvas.width-2, this.canvas.height-2);
        
        
        for (let row = 0; row < 20; row++) {
          const line = this.rows[row] || '';
          const colorLine = this.colorRows[row] || [];
          
          if (line.length > 0) {
            console.log(`Rendering row ${row}: "${line}"`);
          }
          
          for (let col = 0; col < line.length; col++) {
            const char = line[col];
            const colors = colorLine[col] || { text: this.currentTextColor, background: this.currentBackgroundColor };
            
            const x = 10 + (col * this.charWidth);  // 10px border
            const y = 10 + (row * this.charHeight);
            
            // Draw background color only if not transparent
            if (colors.background !== -1 && colors.background !== this.currentBackgroundColor) {
              this.ctx.fillStyle = this.C64_COLORS[colors.background];
              this.ctx.fillRect(x, y, this.charWidth, this.charHeight);
            }
            
            // Draw character with color
            this.drawPixelChar(char, col, row, colors.text);
          }
        }
        
        // Draw cursor
        this.drawCursor(this.currentCol, this.currentRow);
      }
      
      drawPixelChar(char, col, row, colorIndex = null) {
        const borderSize = 10;
        const x = borderSize + (col * this.charWidth);
        const y = borderSize + (row * this.charHeight);
        
        // Use color from parameter or current text color
        const color = colorIndex !== null ? this.C64_COLORS[colorIndex] : this.C64_COLORS[this.currentTextColor];
        
        // Use original TRS-80 5√ó7 bitmap font data with color
        this.drawChar5x7(char, x, y, color);
      }
      
      drawCursor(col, row) {
        const borderSize = 10;
        const x = borderSize + (col * this.charWidth);
        const y = borderSize + (row * this.charHeight);
        
        // Blinking cursor - only show every other blink cycle
        if (Math.floor(Date.now() / 500) % 2) {
          this.ctx.fillStyle = '#000000';
          // Draw cursor as a solid block in the 5√ó7 area (not the full cell)
          for (let r = 0; r < 7; r++) {
            for (let c = 0; c < 5; c++) {
              this.ctx.fillRect(
                x + (c * this.pixelSize),
                y + (r * this.pixelSize),
                this.pixelSize,
                this.pixelSize
              );
            }
          }
        }
      }
      
      // Color control methods for Kindle compatibility
      setTextColor(colorIndex) {
        if (colorIndex >= 0 && colorIndex <= 15) {
          this.currentTextColor = colorIndex;
          console.log('SimpleTRS80: Text color set to', colorIndex, this.C64_COLORS[colorIndex]);
        }
      }
      
      setBackgroundColor(colorIndex) {
        if (colorIndex >= 0 && colorIndex <= 15) {
          this.currentBackgroundColor = colorIndex;
          console.log('SimpleTRS80: Background color set to', colorIndex, this.C64_COLORS[colorIndex]);
        }
      }
      
      // Clear screen - essential for CLS command
      clearScreen() {
        console.log('SimpleTRS80.clearScreen called');
        // Reset all rows to empty strings
        for (let i = 0; i < 20; i++) {
          this.rows[i] = '';
          this.colorRows[i] = new Array(40).fill({
            text: this.currentTextColor, 
            background: -1  // Transparent
          });
        }
        // Reset cursor position
        this.currentRow = 0;
        this.currentCol = 0;
        console.log('SimpleTRS80: Screen cleared, cursor reset to 0,0');
        this.render(); // Immediately refresh display
      }
      
      // Print text without newlines - convenience method for BASIC commands
      printText(text) {
        console.log('SimpleTRS80.printText called with:', JSON.stringify(text));
        for (let i = 0; i < text.length; i++) {
          console.log('printText: adding char', JSON.stringify(text[i]));
          this.addChar(text[i]);
        }
        console.log('printText: complete, current rows:', this.rows);
        this.render(); // Force a render after printing
      }
      
      // Simple 5x7 font renderer for Kindle compatibility
      drawChar5x7(char, x, y, color) {
        // Basic 5x7 font data for essential characters
        const fontData = {
          ' ': [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
          '!': [0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x04],
          '"': [0x0A, 0x0A, 0x0A, 0x00, 0x00, 0x00, 0x00],
          '#': [0x0A, 0x0A, 0x1F, 0x0A, 0x1F, 0x0A, 0x0A],
          '$': [0x04, 0x0F, 0x14, 0x0E, 0x05, 0x1E, 0x04],
          '%': [0x18, 0x19, 0x02, 0x04, 0x08, 0x13, 0x03],
          '&': [0x06, 0x09, 0x09, 0x06, 0x15, 0x09, 0x16],
          "'": [0x04, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00],
          '(': [0x02, 0x04, 0x08, 0x08, 0x08, 0x04, 0x02],
          ')': [0x08, 0x04, 0x02, 0x02, 0x02, 0x04, 0x08],
          '*': [0x00, 0x04, 0x15, 0x0E, 0x15, 0x04, 0x00],
          '+': [0x00, 0x04, 0x04, 0x1F, 0x04, 0x04, 0x00],
          ',': [0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x08],
          '-': [0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00],
          '.': [0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C],
          '/': [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x00],
          '0': [0x0E, 0x11, 0x13, 0x15, 0x19, 0x11, 0x0E],
          '1': [0x04, 0x0C, 0x04, 0x04, 0x04, 0x04, 0x0E],
          '2': [0x0E, 0x11, 0x01, 0x02, 0x04, 0x08, 0x1F],
          '3': [0x1F, 0x02, 0x04, 0x02, 0x01, 0x11, 0x0E],
          '4': [0x02, 0x06, 0x0A, 0x12, 0x1F, 0x02, 0x02],
          '5': [0x1F, 0x10, 0x1E, 0x01, 0x01, 0x11, 0x0E],
          '6': [0x06, 0x08, 0x10, 0x1E, 0x11, 0x11, 0x0E],
          '7': [0x1F, 0x01, 0x02, 0x04, 0x08, 0x08, 0x08],
          '8': [0x0E, 0x11, 0x11, 0x0E, 0x11, 0x11, 0x0E],
          '9': [0x0E, 0x11, 0x11, 0x0F, 0x01, 0x02, 0x0C],
          ':': [0x00, 0x0C, 0x0C, 0x00, 0x0C, 0x0C, 0x00],
          ';': [0x00, 0x0C, 0x0C, 0x00, 0x0C, 0x04, 0x08],
          '<': [0x02, 0x04, 0x08, 0x10, 0x08, 0x04, 0x02],
          '=': [0x00, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x00],
          '>': [0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08],
          '?': [0x0E, 0x11, 0x01, 0x02, 0x04, 0x00, 0x04],
          '@': [0x0E, 0x11, 0x01, 0x0D, 0x15, 0x15, 0x0E],
          'A': [0x0E, 0x11, 0x11, 0x11, 0x1F, 0x11, 0x11],
          'B': [0x1E, 0x11, 0x11, 0x1E, 0x11, 0x11, 0x1E],
          'C': [0x0E, 0x11, 0x10, 0x10, 0x10, 0x11, 0x0E],
          'D': [0x1C, 0x12, 0x11, 0x11, 0x11, 0x12, 0x1C],
          'E': [0x1F, 0x10, 0x10, 0x1E, 0x10, 0x10, 0x1F],
          'F': [0x1F, 0x10, 0x10, 0x1E, 0x10, 0x10, 0x10],
          'G': [0x0E, 0x11, 0x10, 0x17, 0x11, 0x11, 0x0F],
          'H': [0x11, 0x11, 0x11, 0x1F, 0x11, 0x11, 0x11],
          'I': [0x0E, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0E],
          'J': [0x07, 0x02, 0x02, 0x02, 0x02, 0x12, 0x0C],
          'K': [0x11, 0x12, 0x14, 0x18, 0x14, 0x12, 0x11],
          'L': [0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1F],
          'M': [0x11, 0x1B, 0x15, 0x15, 0x11, 0x11, 0x11],
          'N': [0x11, 0x11, 0x19, 0x15, 0x13, 0x11, 0x11],
          'O': [0x0E, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E],
          'P': [0x1E, 0x11, 0x11, 0x1E, 0x10, 0x10, 0x10],
          'Q': [0x0E, 0x11, 0x11, 0x15, 0x12, 0x0E, 0x01],
          'R': [0x1E, 0x11, 0x11, 0x1E, 0x14, 0x12, 0x11],
          'S': [0x0F, 0x10, 0x10, 0x0E, 0x01, 0x01, 0x1E],
          'T': [0x1F, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04],
          'U': [0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E],
          'V': [0x11, 0x11, 0x11, 0x11, 0x11, 0x0A, 0x04],
          'W': [0x11, 0x11, 0x11, 0x15, 0x15, 0x15, 0x0A],
          'X': [0x11, 0x11, 0x0A, 0x04, 0x0A, 0x11, 0x11],
          'Y': [0x11, 0x11, 0x11, 0x0A, 0x04, 0x04, 0x04],
          'Z': [0x1F, 0x01, 0x02, 0x04, 0x08, 0x10, 0x1F],
          'a': [0x00, 0x00, 0x0E, 0x01, 0x0F, 0x11, 0x0F],
          'b': [0x10, 0x10, 0x16, 0x19, 0x11, 0x11, 0x1E],
          'c': [0x00, 0x00, 0x0E, 0x10, 0x10, 0x11, 0x0E],
          'd': [0x01, 0x01, 0x0D, 0x13, 0x11, 0x11, 0x0F],
          'e': [0x00, 0x00, 0x0E, 0x11, 0x1F, 0x10, 0x0E],
          'f': [0x06, 0x09, 0x08, 0x1C, 0x08, 0x08, 0x08],
          'g': [0x00, 0x0F, 0x11, 0x0F, 0x01, 0x0E, 0x10],
          'h': [0x10, 0x10, 0x16, 0x19, 0x11, 0x11, 0x11],
          'i': [0x04, 0x00, 0x0C, 0x04, 0x04, 0x04, 0x0E],
          'j': [0x02, 0x00, 0x06, 0x02, 0x02, 0x12, 0x0C],
          'k': [0x10, 0x10, 0x12, 0x14, 0x18, 0x14, 0x12],
          'l': [0x0C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0E],
          'm': [0x00, 0x00, 0x1A, 0x15, 0x15, 0x11, 0x11],
          'n': [0x00, 0x00, 0x16, 0x19, 0x11, 0x11, 0x11],
          'o': [0x00, 0x00, 0x0E, 0x11, 0x11, 0x11, 0x0E],
          'p': [0x00, 0x00, 0x1E, 0x11, 0x1E, 0x10, 0x10],
          'q': [0x00, 0x00, 0x0D, 0x13, 0x0F, 0x01, 0x01],
          'r': [0x00, 0x00, 0x16, 0x19, 0x10, 0x10, 0x10],
          's': [0x00, 0x00, 0x0E, 0x10, 0x0E, 0x01, 0x1E],
          't': [0x08, 0x08, 0x1C, 0x08, 0x08, 0x09, 0x06],
          'u': [0x00, 0x00, 0x11, 0x11, 0x11, 0x13, 0x0D],
          'v': [0x00, 0x00, 0x11, 0x11, 0x11, 0x0A, 0x04],
          'w': [0x00, 0x00, 0x11, 0x11, 0x15, 0x15, 0x0A],
          'x': [0x00, 0x00, 0x11, 0x0A, 0x04, 0x0A, 0x11],
          'y': [0x00, 0x00, 0x11, 0x11, 0x0F, 0x01, 0x0E],
          'z': [0x00, 0x00, 0x1F, 0x02, 0x04, 0x08, 0x1F],
          '[': [0x0E, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0E],
          ']': [0x0E, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0E]
        };
        
        const charData = fontData[char.toUpperCase()] || fontData[' '];
        this.ctx.fillStyle = color;
        
        for (let row = 0; row < 7; row++) {
          const rowData = charData[row];
          for (let col = 0; col < 5; col++) {
            if (rowData & (1 << (4 - col))) {
              const pixelX = x + col * this.pixelSize;
              const pixelY = y + row * this.pixelSize;
              this.ctx.fillRect(pixelX, pixelY, this.pixelSize, this.pixelSize);
            }
          }
        }
      }
    }
    
    // ========================================
    // SYSTEM INITIALIZATION
    // ========================================
    
    // Simple unified initialization
    setTimeout(function() {
      console.log('=== Unified system initialization ===');
      
      // Initialize fallback display if ES6 modules didn't load
      if (!window.trs80) {
        console.log('‚ö† ES6 modules failed, initializing fallback display');
        window.simpleTRS80 = new SimpleTRS80();
        document.getElementById('status-msg').textContent = 'System Status: ‚úì Fallback Ready';
        document.getElementById('status-msg').style.color = '#ff8800';
      } else {
        console.log('‚úì ES6 modules loaded successfully');
        document.getElementById('status-msg').textContent = 'System Status: ‚úì Ready';
        document.getElementById('status-msg').style.color = '#006600';
      }
      
      // Show initial Apple IIe style prompt
      setTimeout(function() {
        // Only show prompt if ES6 modules didn't load (avoid double prompts)
        if (!window.trs80) {
          showPrompt();
        }
      }, 100);
      
      console.log('=== Unified system ready ===');
    }, 1000);
  </script>
</body>
</html>